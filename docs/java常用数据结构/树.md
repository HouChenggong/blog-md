## 树相关

### 哈曼西树

```
import java.util.PriorityQueue;
import java.util.Queue;

/**
 * @author xiyou
 * 漫画解读什么是哈曼西树
 * https://mp.weixin.qq.com/s/dX-8zmSemS0jU21esEYhZA
 */
public class HuffmanTree {

    private HmNode root;

    private HmNode[] list;


    public static void main(String[] args) {
        int arr[] = new int[]{2, 3, 7, 9, 18, 25};
        HuffmanTree tree = new HuffmanTree();
        tree.createHuffmanTree(arr);
        tree.outPrint(tree.root);
    }

    public void createHuffmanTree(int[] weight) {
        Queue<HmNode> nodeQueue = new PriorityQueue<>(weight.length);
        list = new HmNode[weight.length];

        /**
         * 初始化优先队列和原始node
         */
        for (int i = 0, len = weight.length; i < len; i++) {
            list[i] = new HmNode(weight[i]);
            nodeQueue.add(list[i]);
        }
        //主循环，当结点队列只剩一个结点时结束
        while (nodeQueue.size() > 1) {
            HmNode left = nodeQueue.poll();
            HmNode right = nodeQueue.poll();
            //parent
            HmNode parent = new HmNode(left.weight + right.weight, left, right);
            nodeQueue.add(parent);
        }
        root = nodeQueue.poll();
    }


    //前序遍历结果输出
    public void outPrint(HmNode node) {
        if (node == null) {
            return;
        }
        System.out.println(node.weight);
        outPrint(node.left);
        outPrint(node.right);

    }

    /*
        构建树,因为使用的是优先队列，所以用实现比较接口
     */
    public static class HmNode implements Comparable<HmNode> {
        int weight;
        HmNode left;
        HmNode right;

        public HmNode(int weight, HmNode left, HmNode right) {
            this.weight = weight;
            this.left = left;
            this.right = right;
        }

        public HmNode(int weight) {
            this.weight = weight;
        }

        @Override
        public int compareTo(HmNode node) {
            return Integer.valueOf(this.weight).compareTo(Integer.valueOf(node.weight));
        }
    }

}
```

### AVL树（平衡二叉树）

它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树

#### AVL树与红黑树（R-B树）的区别与联系

- AVL是严格的平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；
- 红黑树是用非严格的平衡来换取增删节点时候旋转次数的降低开销；
- 所以简单说，查询多选择AVL树，查询更新次数差不多选红黑树
- AVL树顺序插入和删除时有20%左右的性能优势，红黑树随机操作15%左右优势，现实应用当然一般都是随机情况，所以红黑树得到了更广泛的应用 索引为B+树 Hashmap为红黑树

#### 为啥redis zset使用跳跃链表而不用红黑树实现

- skiplist的复杂度和红黑树一样，而且实现起来更简单。
- 在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。
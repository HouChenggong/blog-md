MySQL事务

#  ACID 

![](.\img\ACID.png)

## 1、redo log 和undo log

 ![](.\img\原子性实现undolog.png)

#### 正常事务的执行流程

修改一条记录的顺序是：如把id为1的记录的age=1修改成2

```css
1. 事务A 开始
2. undo 复制记录undo log中记录原来的值1，也可以理解为update set age=1 where id =1
3.执行update语句，相当于又创建了一个记录，同时把roll指针指向原来的记录的trx_id上
4.记录redo log age=2
5. 将redo log 写入磁盘
6. 事务提交，将数据写入磁盘
7.事务结束
```

##### redolog和事务谁优先写入磁盘数据？

其中，redo日志必须先于数据写入磁盘（即步骤5和步骤6的顺序不能改变）。因为如果不这样，在数据提交之后再写redo日志，一旦redo日志的写入过程出现异常，将无法保证持久性。

记录redo日志时，先记入redo log buffer，最后再一起写入磁盘，这样可以减少IO，提升性能。

另外，未提交的事务和回滚了的事务也会计入redo日志。

#### 回滚的事务提交过程

```
1. 事务A 开始
2. undo 记录原来的值1，也可以理解为update set age=1 where id =1
3.执行update语句
4.记录redo log age=2
---- 这时出现异常回滚
+1 将age修改回1
+2记录 redo log
-----
5. 将redo log 写入磁盘
6. 事务提交，将数据写入磁盘
7.事务结束
```

回滚提交的事务，首先会根据先后顺序的逆序把值改回原来的，然后再记录redo log，其实就是多了这两步操作

#### checkpoint机制

redo日志会随着时间推移而越来越大，为了提升redo的恢复性能，引入了**checkpoint机制**，在恢复的时候，只需要从checkpoint的位置往后恢复即可。

------

#### MySQL恢复策略

mysql的恢复策略是：

1. 恢复时，先根据**redo**重做所有事务（包括未提交和回滚了的）
2. 再根据**undo**回滚未提交的事务。

比如上面事务A未提交事务的时候宕机，恢复时，先根据redo日志将数据恢复为age=2，然后根据undolog 把记录变成age=1恢复如初

事务B也是提交事务的时候宕机，恢复时根据redo日志，可以直接恢复至`age=1`的初始状态。







可重复读：读的是事务开始数据快照的状态

不可重复读:读的是最新数据持久化的状态

## 幻读

### 读幻读

读幻读：两次结果查询不一样

解决方案：RC级别改为RR级别

原理：MVCC版本链

### 写幻读

- 事务A查询id=5的记录不存在，但是插入的时候插入失败，因为另一个事务已经插入
- 事务A查询的时候有5条记录，但是更新的时候有6个记录，原因另一个事务执行了相关操作

比如下面的示例：

```java
1. 事务A 开始 事务B 开始
2. 事务A插入id=5的记录
	此时事务B是无法看到id=5的记录	
3. 事务B再次插入id=5的记录
	这个时候事务B会发生阻塞，卡死不能进行任何操作，直到事务A提交为止
4. 事务A提交
	此时事务B阻塞完成，但是这个时候他插入id=5的记录就会报错，如下：
	1062 - Duplicate entry '5' for key 'PRIMARY'
而且此时他再查询数据库，还是看不到id=5的记录，所以对他而言，就好像幻觉一样，id=5的记录没有却插入不了
5.事务B错误回滚，在整个过程中他都看不到id=5的记录已经被插入了
```

所以 mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。

解决写幻读的方案：next-key锁，即select for update

### redo log

redo log 重做日志

作用：保证ACID的持久化，即事务一旦修改，就要保证其持久化保存

即保证发生故障的时候尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到持久性。

#### redo log 产生时机

```java
1. 事务A 开始
2. undo 复制记录undo log中记录原来的值1，也可以理解为update set age=1 where id =1
3.执行update语句，相当于又创建了一个记录，同时把roll指针指向原来的记录的trx_id上
4.记录redo log age=2
5. 将redo log 写入磁盘
6. 事务提交，将数据写入磁盘
7.事务结束
```



#### 为啥引入redo log 

WAL全称是write ahead log，也就是更新数据之前先更新日志

磁盘的写操作是随机io，比较耗性能，所以如果把每一次的更新操作都先写入log中，那么就成了顺序写操作，实际更新操作由后台线程再根据log异步写入。这样对于client端，延迟就降低了。并且，由于顺序写入大概率是在一个磁盘块内，这样产生的io次数也大大降低。所以WAL的核心在于将随机写转变为了顺序写，降低了客户端的延迟，提升了吞吐量。

至于说redo log可以恢复数据，这不是原因，而是结果。如果不用WAL，就直接每一次都裸写磁盘，那根本不会有什么数据恢复的问题，什么时候宕机，那个时候之前的数据就是写入成功的。换句话说，正是因为用了WAL，才需要考虑宕机数据恢复的问题，因为有些数据还没刷到磁盘上啊。

 

##### redolog和事务谁优先写入磁盘数据？

其中，redo日志必须先于数据写入磁盘。因为如果不这样，在数据提交之后再写redo日志，一旦redo日志的写入过程出现异常，将无法保证持久性。

记录redo日志时，先记入redo log buffer，最后再一起写入磁盘，这样可以减少IO，提升性能。

另外，未提交的事务和回滚了的事务也会计入redo日志。

#### redo log与buffer pool

正如之前提到的，MySQL 不会直接去修改磁盘的数据，因为这样做太慢了，MySQL 会先改内存，然后记录 redo log，等有空了再刷磁盘，如果内存里没有数据，就去磁盘 load。

而这些数据存放的地方，就是 Buffer Pool。

- 所以：buffer pool是一种减少磁盘io读的机制，原理是将访问过的磁盘数据暂留在内存中，这样下次访问相同的数据就不需要读磁盘了。



#### 脏数据刷盘

Checkpoint 机制：checkpoint触发后，将buffer中的脏数据和脏日志页都刷新到磁盘中



#### redo log脏日志刷盘

Redo log并不是时机刷盘的，它有个缓存区，innodb_log_buffer,默认8M，刷盘主要有三个机制

1. 每秒刷盘
2. 事务提交的时候刷盘
3. 当重做日志缓存空间少于一半的时候，重做日志缓存刷新到重做日志文件

### undo log

实现MVCC的重要组成部分，保证事务ACID的原子性，即发生错误可以回滚



### binlog和relay log

Binlog 实现数据复制的重要组成部分

Relay log 是中继日志

### error log



### slow query log


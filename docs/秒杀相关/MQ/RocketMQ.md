  

## RocketMQ

### 集群架构

- nameServer
  - 类似zookeeper功能的一个轻量级名字服务，具有简单、集群横向扩展、无状态等特点
  - 一般一个集群部署2台NameServer服务器
- Broker
  - 消息中转器，用于消息保存和转发
- Produce集群
  - 生产消息的集群
- Consumer集群
  - 消费消息的集群

### 主要功能

- 高可用——不丢消息

- 高吞吐量（可以替换ActiveMQ）生产、消费

- 高可用

- 监控、报警

- 持久化——消息可以保存7天

- 多消息类型（无序、分区有序、全局有序）

- 回溯消费——多次消费

  

### 消费模式

#### 集群消费

- 平分消息


  - 消息消费失败进行重复投递，大于15次，进入死信队列并报警

#### 广播消费

  - 无失败处理，需要业务方自行处理

  

### 名词解释

#### 死信消息

-  消息消费重试发送16次失败、消息被拒绝并且不再重新投递，会产生一个名为%DLQ%+consumergroup的队列，这个队列为死信队列

#### 消息堆积

-  消息发送的速率远远大于消息消费的速率导致消息堆积

### 功能介绍

#### 并发消费
- 消息并发消费，异常消费不会阻塞消费
- 消息消费异常，异常的消息会发回重试队列
-  默认重试16次

#### 顺序消费
  - 消息顺序消费，队列会被lock，异常消息不能跳过
  - 异常消息不能跳过，会不断重试，消息顺序性可能得到保证
#### 超时消费
  - 单个消息阻塞时间默认15分钟
  - 超时后会进入重试队列
### 消息分类

#### 单项消息OneWay

#### 同步普通消息

#### 异步普通消息

#### 全局有序消息
  - 保证顺序发送、顺序存储、顺序消费
  - 1.1）单线程发送、上一个成功才能发送下一个
  - 1.2）只能同步发送
  - 消息顺序存储
  - 2.1）由于一个消息Topic会有多个Queue，要保证顺序存储，需要将同一个业务的消息发送到同一个Queue。即对业务编号进行取余，将消息发送到同一个队列中
  - 消息顺序消费：同一时刻一个消费队列queue只能被一个线程消费

#### 分区有序消息

  - 对于一个topic所有消息会根据sharding key进行区块分区，同一个分区内的消息会严格按照FIFO顺序发布和消费

    sharding key 是顺序消息中用来区分不同分区的字段，和普通消息的key不是一个概念

#### 延时消息

  - 并非精确到时分秒，而是有一个颗粒度

#### 广播消息

  - 每一个消费者组都会收到消息

#### 事物消息

  - VKMQ 提供类似 X/Open XA 的分布事务功能，通过 VKMQ 事务消息能达到分布式事务的最终一致。

#### 批量处理消息

  - 一批消息只会被一个队列消费，另一个队列消费不到

#### 条件筛选消息

  - 类似SQL过滤
#### 异常情况

- NameServer高可用

  - 一台下线无影响

  - 全部下线运行时

    1）对已启动的producer无影响，新启动的producer会报错

    2）对已启动的consumer无影响，新启动的Consumer不会报错，但也无法消费消息

    3）对现有broker无影响，新启动时会报错

- Broker高可用
  - 一台master下线——无影响
  - 全部下线：生产者不能写入，消费者无影响
  - master重新上线：会有少量重复消费，tps增加一倍
  - slave下线：无影响
  - 机器断电：会丢失少量消息，因为操作系统无机会落盘
  - 磁盘满了：会删除最早的消息
  - 网络带宽满了：用大量消息压测，发现带宽满了之后会有大量消息失败

- 增加Consumer
  - 会马上Rebalance
  - 注意队列数和消费者数，消费者大于queueSize时，新增的消费者会空跑

### 如何保证消息不丢失？

再说消息丢失之前，我们先来看下一个正常消息的整个链路流程

Producer——【Broker OS Cache ——磁盘】——Consumer

[最佳实战](http://wiki.vipkid.com.cn/pages/viewpage.action?pageId=161856241)

#### 1-producer——Broker发消息

- 场景一：单项详细（OneWay）
  - Producer不等待Broker返回结果，有可能Broker没有收到消息导致丢失消息
- 场景二：MQ不保证Producer消息发送一定成功导致消息丢失
  - 同步消息：当Producer向Broker发送消息，如果**失败次数超过限制**，则不再发送
  - 异步消息：Producer发送给broker后，Broker会通过异步机制回调给Producer，**MQ对异步消息发送失败不会自动重试**
- 对于上述同步和异步发消息场景，当Producer向Broker发消息失败，如果业务要求消息一定不能丢，推荐业务使用下述方案：
  - 一、业务把失败的消息持久化存储（如存到DB），然后启动线程通过定时任务重试，直到发到Broker成功
  - 二、业务重试的时候注意失效性、注意顺序性

#### 2-Broker OS Cache ——磁盘刷消息，同步、异步刷盘

考虑下面的场景：

1. Broker正常关机
2. Broker异常Crash
3. OS Crash
4. 集群断电，但能立即恢复供电
5. 集群无法开机（可能CPU、主板、内存等关键设备损坏）
6. 磁盘设备损坏

- 可能丢消息场景一：
  - 1~4 在异步刷盘的模式下会丢少量消息；
  - 同步刷盘模式下不会丢消息。

- 可能丢消息场景二：
  - 5~6 属于单点故障，一旦发生，该节点上的消息全部丢失，如果开启了主从，则可去从节点消费消息；
  - 如果开启了异步复制机制，VKMQ只丢少量消息。
- 建议：如果严格要求不丢失消息，开启同步刷盘，但是并发会下降很多，但是无论是哪种刷盘模式都要开启主从

#### 3-Consumer——Broker消费消息

- 可能丢消息场景一：Consumer消费到消息，在业务处理成功前，就提交了offset

- 可能丢消息场景二：MQ在Broker服务器上保存有过期时间（默认为48小时），过期的消息会被统一清理。所以如果在清理前没有被Consumer消费的消息会丢。

- 可能丢消息场景三：消息反复消费失败进入死信队列：

1）有序消息：这种情况失败会一直重试，会阻塞后面的消息消费；
2）无序消息：这种消息在第一次消费失败就会进入重试消息队列 ，在这个队列会以时间梯度的方式重复发送16次 （可配），再次失败会进入死信队列， 这时候会有相关告警，要再需要这条消息就需要人工介入处理

- 建议：
  - 一定要业务处理完成再提交消息成功
  - 备用方案去拉取消息
  - 具备死信消息处理机制

### 如果保证消息不乱序

所谓消息有序，指消息消费者按照消息到达消息存储服务器的顺序消费。

需要由3个阶段去保障：

#### 1-消息被发送时保持顺序

- 在同一个线程中采用同步的方式发送。

#### 2-消息被存储时保持和发送的顺序一致

确保要排序的消息路由到同一个队列中。

#### 3-消息被消费时保持和存储的顺序一致

不对收到的消息的顺序进行调整，即只要一个分区的消息只由一个线程处理即可。

VKMQ顺序消息分为全局有序和分区有序。

1）全局有序：一个topic内的所有消息都发送到同一个队列。缺点是响性能不如多个队列并行消费好。

#### 4-瞬时乱序行为？

2）分区有序：消息根据key落到不同的分区（队列），可保证同一分区内消息有序。缺点是一旦队列总数变化（如Broker重启等），会导致落点错乱，导致瞬时乱序。

### 如何保证消息不重复消费

- 业务去重

#### 常见MQ异常

- broker busy

如果消息量很小观察下，有必要进行扩容

如果消息量很大，进行扩容

- TimeOutClientQueue

  一般解决方案是扩容，还可以把磁盘换成SSD

### 最佳实战

#### Producer

##### 生产者发送消息注意事项

1. 建议**消息大小**不要超过512K,

2. **默认的发送**为同步发送，send方法会一直阻塞，等待broker端的响应。如果你关注性能问题，可以通过send(msg, callback)来发起异步调用。

3. 正常情况下**生产者组**是没有作用的，但是在发送事务消息时，如果producer中途意外宕机，broker会主动回调producer group 内的任意一台机器来确认事务的状态

4. **生产者实例**是**线程安全**的，在应用中只需要实例化一次即可

5. 性能问题

   如果你希望在一个jvm进程内使用多个producer实例来提高发送能，我们建议：

   - 使用异步发送，并且producer实例只需要3 ~ 5个即可
   - 对每一个producer 调用 setInstanceName，区别不同的生产者

6. 当客户端向broker发送请求超时时，客户端会抛出 RemotingTimeoutException，默认的超时时间是3秒。通过调用send(msg, timeout) 可以设置超时时间。**超时时间**建议不要设置过小，因为 broker 可能需要时间刷盘或向 slave 同步数据

7. 对于同一个应用最好只使用一个Topic，消息的子类型可以使用 **tags** 来标识，tags 可以由应用自由设置。当发送的消息设置了 tags 时，消费方在订阅消息时可以使用 tags 在 broker 做消息过滤。注意这里的命名虽然是复数，但是一条消息只能有一个tag

8. 消息在业务层面的唯一标识可以设置到 keys 字段，方便根据 keys 来定位消息。broker 会为每个消息创建索引（哈希索引），应用可以通过topic 、key 查询这条消息的内容(MessageExt)，以及消息被谁消费（MessageTrack，精确到consumer group）。由于是哈希索引，请尽量保证key 的唯一，这样可以避免潜在的哈希冲突

9. 消息发送不管是成功还是失败都要**打印消息日志**，日志内容务必包含 sendResult 和 key 字段

10. 对于消息不可丢失的应用，务必要有**消息重发机制**。例如如果消息发送失败，可以将消息存储到数据库，然后通过定时程序或者人工的方式触发重发

11. 调用send 同步发送消息时，假定此时设置了 isWaitStoreMsgOK=true(default is true)，只要不抛出异常就代表发送成功，但当 isWaitStoreMsgOK = false 时，发送永远返回 SEND_OK。但是对于发送“成功”会有多个状态，在 SendStatus 中定义如下：

    - FLUSH_DISK_TIMEOUT

      如果 broker 设置的 FlushDiskType = SYNC_FLUSH，当 broker 的在刷盘超时时（MessageStoreConfig.syncFlushTimeout，默认5秒）会返回该状态。此时消息任然保存在内存中，只有broker 宕机时消息才会丢失

    - FLUSH_SLAVE_TIMEOU

      如果 broker 的 role 是 SYNC_MASTER，当 slave 同步数据的时间超过了 MessageStoreConfig.syncFlushTimeout (默认5秒) 时会返回此状态。此时只有主从都宕机，并且主也没有刷盘时，消息才会丢失

    - SLAVE_NOT_AVAILABLE

      如果 broker 的 role 是 SYNC_MASTER，并且此时 slave 不可用时会返回该状态

    - SEND_OK

      发送成功。为了保证消息不丢失还需要配置 

      SYNC_MASTER or SYNC_FLUSH

12. 当发送消息时返回 FLUSH_DISK_TIMEOUT/FLUSH_SLAVE_TIMEOUT，若非常不幸的 broker 也宕机了，消息将会丢失。此时如果什么都不做，消息可能会丢失，如果重发消息，消息可能会出现重复。

    通常我们建议发送端重发消息，由消费方来保证消息消费的幂等性。



##### 消息发送失败如何处理

Producer 的 send 方法本生支持内部重试，重试逻辑如下：

1. 至多重试3次
2. 如果发送失败，则轮转到下一个broker
3. 这个方法的总耗时时间不超过 sendMsgTimeout，默认3秒
   所以发送消息已经产生超时异常的话就不会再重试。

以上策略仍不能保证消息发送一定成功，为保证消息发送一定成功，建议应用这么做：如果调用 send 同步发送失败，则尝试将消息存储到db，由后台线程定时重试，保证消息一定到达 Broker

##### 顺序消息问题

顺序消息分为分区有序和全局有序。

分区有序要求 producer 在send 时传入 MessageQueueSelector 的实现类，最终将某一类消息发送到同一队列。但是一旦发生通信异常、broker 重启等，由于队列总数发生变化，哈希取模后定位的队列会变化，会产生短暂的顺序不一致。如果业务能容忍在集群异常情况下（如某个 broker 宕机或者重启）消息短暂的乱序，使用分区有序比较合适



全局严格有序的消息即便在异常情况下也能保证消息的有序性，但是却牺牲了分布式的 failover 特性，即 broker 集群中只有要一台机器不可用，则整个集群都不可用，服务可用性会大大降低。

 

顺序消息的缺点：

- 发送顺序消息无法利用集群的 FailOver 特性
- 消费顺序消息的并行度依赖于队列数量
- 队列热点问题，个别队列由于哈希不均导致消息过多，消费速度跟不上，产生消费堆积问题
- 遇到消费失败的消息，无法跳过，当前队列需要暂停

#### consumer

##### MessageListener

1）顺序消费 MessageListenerOrderly

顺序消费时消费者会锁定队列，以确保消息被顺序消费，但是这样也会造成一定的性能损耗。当消费出现异常的时候，建议不要抛出异常，而是返回 ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT，让消费暂停一会，暂停时间由 context.setSuspendCurrentQueueTimeMillis 方法指定

2）并发消费

并发消费是推荐的消费方式，在此种模式下，消息将被并发的消费。消费出现异常时不建议抛出异常，只需要返回 ConsumeConcurrentlyStatus.RECONSUME_LATER 即可。为了保证消息肯定被至少消费一次，消息将会被重发回 broker （topic不是原topic而是这个消费组的RETRY topic），在延迟的某个时间点（默认是10秒，业务可设置，通过 delayLevelWhenNextConsume 和 MessageStoreConfig.messageDelayLevel 设置）后，再次投递到这个 ConsumerGroup，而如果一直这样重复消费都持续失败到一定次数（默认是16次，DefaultMQPushConsumer.maxReconsumeTimes），就会投递到DLQ队列。应用可以监控死信队列来做人工干预。

3）返回状态

在并行消费时可以通过返回 RECONSUME_LATER 来告诉 Consumer 当前无法消费该消息，等延时一段时间再重新消费，但是此时消费不会停止，你可以继续消费其他消息。但在顺序消费时，因为要保证消费的顺序性，所以你不能跳过失败的消息，此时你可以通过返回 SUSPEND_CURRENT_QUEUE_A_MOMENT 来告诉 Consumer 先暂停一会。

4）阻塞

不建议阻塞Listener，因为这会阻塞住线程池，同时也有可能造成消费者线程终止

##### consumer线程池 

consumer 内部通过一个 ThreadPoolExecutor 来消费消息，可以通过 setConsumeThreadMin 和 setConsumeThreadMax 来改变线程池的大小

##### 消费速度慢处理方式

1）提高消费并行度

大部分消息消费行为都属于 IO 密集型业务，适当的提高并发度可以显著的改善消费的吞吐量

2）批量方式消费

默认情况下 consumer 的 consumeMessageBatchMaxSize 为1，即一次只消费一个消息，如果应用可以批量消费消息，则可以很大程度上提高消费吞吐量

3）跳过非重要消息

当消堆积严重时可以丢弃不重要的消息

```java
final` `long` `offset = msgs.get(``0``).getQueueOffset();``final` `String maxOffset = msgs.get(``0``).getProperty(MessageConst.PROPERTY_MAX_OFFSET);``final` `long` `diff =Long.valueOf(maxOffset) - offset;``if` `(diff > ``100000``){``  ``return` `ConsumeConcurrentlyStatus.CONSUME_SUCCESS;``}
```

4) 优化消息消费过程

##### 集群消费模式

- 集群消费
  - 保证每条消息只被处理一次
  - 消费进度在服务器维护，可靠性高
  - 消息只会被分发到一台机器，若消费失败，消息重新投递但不保证会投递到原先的机器
- 广播消费
  - 顺序消息不支持广播消费
  - 消费进度在客户端维护
  - 广播模式只保证每条消息被每台服务消费一次，但是不保证消费成功，也就是消费失败并不会重新投递

### 高可用如何保证？

#### 生产者高可用

- 客户端保证
  - 重试机制，无论是同步还是异步发送，如果单个Broker发生故障，重试会选择其它的Broker保证消息正常发送
  - 保证机制，客户端容错，MQ会维护一个Broker——发送延迟的关系，利用这个关系，我们可以选择一个发送延迟级别较低的Broker来发送新消息
- Broker端保证：数据同步方式保证
  - Broker主从复制分为2种，同步和异步
  - 同步复制：消息发送到Master Broker后，同步到Slave Broker才算消息发送成功
  - 异步复制：消息发送到Maser Broker后就认为消息发送成功。
  - 总结：要绝对高可用，进行主从同步复制，大部分场景配置为主从异步复制即可

#### 消费者高可用机制

- 重试-死信机制

  - 投递16次失败后，进行死信队列，名称为：%DLQ消费中组名%
  - 假如是代码BUG，导致数据都死信了，想补偿之前的数据怎么办？

- Rebalance机制

  - Rebalance用于在Broker掉线、Topic扩容、缩容、消费者扩容、缩容等变化时，自动感知并调整

- 消费进度保存机制

##### Rebalance会带来什么负面影响呢

- 消费停滞
- 重复消费：由于Rebalance并不会等待消息提交后再rebalance，所以会有少量重复消费的现象



### MQ相关原理探究

#### 消费者Rebalance机制



#### 消费方式Pull和Push的区别



#### 事物机制原理



| 广播消费问题                       | 全局顺序消费问题                   | 分区顺序问题                         | consumer数量大于队列数量                                    |
| ---------------------------------- | ---------------------------------- | ------------------------------------ | ----------------------------------------------------------- |
| 广播即使消费异常也不会发回到Broker | 一个Broker不可用，整个集群不可用   | Broker重启、扩容、缩容会导致瞬时乱序 | 多出来的consumer实例将无法分到queue<br />也就无法消费到消息 |
| 广播无法处理顺序消费               | 容易产生消息堆积                   |                                      |                                                             |
|                                    | 消费失败无法跳过，当前队列需要暂停 |                                      |                                                             |


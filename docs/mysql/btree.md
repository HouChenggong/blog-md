## mysql索引结构

### 1. 为啥不用Hash索引?

- 严重的HASH冲突问题，对数据的维护效率很低
  - 在增删改查都有严重的影响
- 只支持等值删除
- 不能排序
- 多列索引不支持，比如建立了ABC三个索引，但是单独查询A的时候却不可以
- 不能进行范围查询、in查询等

### 2.为啥不用BTree-?

- 因为B-tree所有的节点都会存储数据，导致树的高度会变高，
- 而内存每次加载数据的大小是有限的，而有数据的时候，加载的量就会很小，如果都是索引，就会加载更多的索引值
- B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
  - BTree-不能像Btree+一样，所有叶子节点（即数据节点）之间是一种链式环结构，这样就能支持范围查询

### 3.一个高度为3的BTree+最多能存储多少数据？

- innodb的所有数据文件.idb大小都是16K即16384的整数倍
- 我们的InnoDB页的大小默认是16k？为啥是16K？因为16K的话，高度为3的树就可以存储千万级别的数据，如下有说明
- 假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。
  我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节
- 我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。
- 那么可以算出一棵高度为2的B+树，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数单个叶子节点记录行数。能存放117016=18720条这样的数据记录。
- 根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170117016=21902400条这样的记录。
- 所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。
- 在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。
   

### 4. 为啥Innodb创建hash索引会失败？

下面是MYSQL官方的回答：
1.不支持HASH索引（但是InnoDB在内部利用哈希索引来实现其自适应哈希索引功能。）

2.也就是InnoDB会根据表的使用情况自动为表生成hash索引，不能人为干预是否在InnoDB一张表中创建HASH索引

3.或者说，如果InnoDB注意到某些索引值被使用的特别频繁时，
它会在内存中基于Btree的索引之上再创建一个HASH索引，这样BTREE索引也具备了HASH索引的一些优点

### 5.ID为啥不推荐使用uuid或者String类型的？

[官网解读](https://dev.mysql.com/doc/refman/8.0/en/innodb-physical-structure.html)

- 因为插入树的时候，要进行分裂
- 由于传统50%分裂的策略，但是mysql进行了改善，最大提高到15/16

将新记录插入`InnoDB` [聚集索引时](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index)，请 `InnoDB`尝试使页面的1/16空闲，以备将来插入和更新索引记录。如果按顺序插入索引记录（升序或降序），则所得到的索引页大约为15/16。如果以随机顺序插入记录，则页面将充满1/2到15/16。

- 所以如果是字符串，则就是随机插入的，空间利用率就会很低


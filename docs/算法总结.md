# 算法

## 位运算

```java
我们先来看下异或的性质（数学里异或的符号是 ⊕）：

交换律：p ⊕ q = q ⊕ p
结合律：p ⊕ (q ⊕ r) = (p ⊕ q) ⊕ r
恒等率：p ⊕ 0 =p
归零率：p ⊕ p =0
```

- N个数字进行异或运算，如果只有一个不同的，那么异或的结果就是那个数字
- N个数字进行异或运算，如果有2个不同的，那么异或的结果是两个不同的数字异或的结果result，即p⊕ q,如果要求出p和q怎么办
  - 分成2组，一组是P，一组是Q，所以现在问题转换到了如何分组上面
  - 对异或的结果进行分析，这个数字从二进制数的角度看，一定有位数为1。这个1是怎么来的？就是那两个只出现一次的数字，异或得到的，他们对应的位不一样，肯定是一个数对应位数出现的是0，另一个数字对应位置上出现的数字是1.据此，将这个数组分成两个部分。
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### lowbit

```java
lowbit（）函数用来取一个二进制最低位的1与后边的0组成的数

例：5（101），lowbit（5）=1（1）

       12（1100），lowbit（12）=4（100）

int lowbit(int t)
{
    return t&(-t);
}
原理，二进制数的负数是正数取反加一

12（1100），-12（0100）
```



##  动态规划

### [力扣542-矩阵找出每个元素到最近的 0 的距离](https://leetcode-cn.com/problems/01-matrix/)

- [解题地址](./docs/算法/力扣542矩阵距离0的最短举例.md)

- BFS解法

- 此题也能用递归做

动态规划解题三要素

- 简单的说就是定义dp[i]表示的问题或者转态是什么。一般来说，这个问题定义清楚，就成功了大半。
- 状态转移方程：转态转移就是根据子问题（上一阶段）状态和决策来导出本问题（当前阶段）的状态，确定了决策方法，就可以写出转态转移方程。
- 边界条件：状态转移方程是一个递推式，需要一个递推的边界条件来最终解出动态规划问题。

 ### [二维数组最大正方形面积](https://leetcode-cn.com/problems/maximal-square/)

```java
221. 最大正方形
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
输入: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
输出: 4
```

其实很好理解，如果

```java
dp[i][j]是以i，j为右下角组成的正方形的最大边长
所以当当前节点是0的时候，最大变成肯定是0
arr[i][j]=0,则当前dp[i][j]=0
当前节点是1，而且处在最左边或者最上边的时候，最大边长就是1
arr[0][j]=1 ,或者arr[i][0]i=1 则当前dp[i][j]=1
如果当前节点不在上诉的限制中，则最大边长是判断（左边、上边、左上边）最小值，然后加1
dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1], dp[i-1][j-1])+1
```



```java
 public int maximalSquare2(char[][] matrix) {
            int maxSide = 0;
            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
                return maxSide;
            }
            int rows = matrix.length, columns = matrix[0].length;
            int[][] dp = new int[rows][columns];
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < columns; j++) {
                    if (matrix[i][j] == '1') {
                        if (i == 0 || j == 0) {
                            dp[i][j] = 1;
                        } else {
                            dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                        }
                        maxSide = Math.max(maxSide, dp[i][j]);
                    }
                }
            }
            int maxSquare = maxSide * maxSide;
            return maxSquare;
        }
```

### 旅行花费问题LC983

[题目：力扣983](https://leetcode-cn.com/problems/minimum-cost-for-tickets/)

题目理解是这样的，一年中只有少数的几天要旅行，要履行的日志标记在days数组中，比如说[1,4,6,7,8,20]就是代表这一年的第1，4，7，8，20天要出行，我们想花费最少的钱怎么办呢？

从前往后判断，假如是1，4，6三天的单个费用已经超过7天的费用，我们何不直接买7天的票呢？所以就是尽量省钱

- 买票的原则是这样的

```sql
今天不需要出门，不用买票
今天如果要出门，需要买几天？
	看往后几天（最多 30 天内）要不要出门
		30 天内都没有要出行的，那只买今天就好
		有要出门的（不同决策）
			这次 和 后面几次 分开买更省
			这次 和 后面几次 一起买更省
 
```

  换个思路，我们从后往前看，答案就出来了

```java
class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        int len = days.length, maxDay = days[len - 1], minDay = days[0];
        int[] dp = new int[maxDay + 31]; // 多扩几天，省得判断 365 的限制
        // 只需看 maxDay -> minDay，此区间外都不需要出门，不会增加费用
        for (int d = maxDay, i = len - 1; d >= minDay; d--) {
            // i 表示 days 的索引
            // 也可提前将所有 days 放入 Set，再通过 set.contains() 判断
            if (d == days[i]) {
                dp[d] = Math.min(dp[d + 1] + costs[0], dp[d + 7] + costs[1]);
                dp[d] = Math.min(dp[d], dp[d + 30] + costs[2]);
                i--; // 别忘了递减一天
            } else dp[d] = dp[d + 1]; // 不需要出门
        }
        return dp[minDay]; // 从后向前遍历，返回最前的 minDay
    }
}
 
```



## 滑动窗口

### 力扣1248滑动窗口求组合数量

- 解题思路，利用滑动窗口和公式（left偶数和+1）*（right偶数和+1）
- [解题地址](./docs/算法/1248.md)

### 无重复最长子字符串

- 力扣3题，解题思路是滑动窗口
  - 利用一个Map存放当前已经存放过的数据
  - 当发现一个数据出现重复的时候，更新Left指针

```java
   public int lengthOfLongestSubstring(String s) {
        if (s.length()==0) return 0;
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        int max = 0;
        int left = 0;
        for(int i = 0; i < s.length(); i ++){
            if(map.containsKey(s.charAt(i))){
                left = Math.max(left,map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i),i);
            max = Math.max(max,i-left+1);
        }
        return max;
        
    }
```




##   双指针



###  力扣11，盛水最多的容器

- [解题地址](./docs/算法/lt11盛水最多的容器.md)

### 力扣202 快乐数

- 解题思路，用快慢指针找有没有环即可


##  递归
### 力扣200 找出岛屿数量

- [解题地址](./docs/算法/力扣200找出岛屿数量.md)

### 二叉树首个共同祖先

- [解题地址](./docs/算法/二叉树首个共同祖先.md)


## 普通BFS

```java
while queue 不空：
    cur = queue.pop()
    for 节点 in cur的所有相邻节点：
        if 该节点有效且未访问过：
            queue.push(该节点)
```

###  力扣542-矩阵找出每个元素到最近的 0 的距离

  - [解题地址](./docs/算法/力扣542矩阵距离0的最短举例.md)

  - BFS解法

  - 此题也能用递归做
### 力扣200 找出岛屿数量

[解题地址](./docs/算法/力扣200找出岛屿数量.md)






##  带有层级的BFS



```java
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for 节点 in cur的所有相邻节点：
            if 该节点有效且未被访问过：
                queue.push(该节点)
    }
    level ++;
```
## 递归回溯算法

```java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```

核心是：

```java
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
 
```



#### 全排列问题



  -  比如说是1，2，3，4，5

  -  核心是撤销和选择，也就是前序遍历问题，当遍历到最后一层i=4,也就是1，2，3，4，5，把最后一个5撤销，然后回到i=3,然后把4也撤销，把5填上，然后挨个撤销和补上

```
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
    public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        List<List<Integer>> res = new ArrayList<>(factorial(len));
        if (len == 0) {
            return res;
        }
        Deque<Integer> path = new ArrayDeque<>(len);
        dfs(nums, len, 0, path, res);
        return res;
    }
	//计算全排列总数据量
    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i <= n; i++) {
            res *= i;
        }
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque<Integer> path, 
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < len; i++) {
        //排除不合法的请求
            if (!path.contains(nums[i])) {
                //一条路径里添加当前值
                path.addLast(nums[i]);
                //进入下一层决策树
				//递归调用剩下的组合，这个和二叉树差不多都是前序遍历，会先遍历完一条路径
                dfs(nums, len, depth + 1, path, res);
				//移掉最后一个
                path.removeLast();
               
            }
        }
    }
}
 
```



#### N皇后问题

其实也是套用模板只不过不再是`if (!path.contains(nums[i]))`

而是： `if (!isValid(board, row, col)) continue;`

只要你实现这个isValid算法即可

## 贪心算法

#### 求出去AB城市的最少费用

```java
公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。
返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。
示例：
输入：[[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。
最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
```

- 题解：只需要重写sort接口，然后取前1半的数据即可

#### 跳跃游戏

```java
55. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例 2:
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

- 题解一：贪心算法，就挨着跳，每一步计算当前能跳的最远值，如果最远值大于目标值，true，如果结束了，最远值还是小于目标值，则false
- 题解二：其实只要数组的值大于0，都能跳，所以我们就找0，找到一个0，向前面遍历，看看它前面的数字是否能跳过它即可

#### 最后一块石头的重量

```java
有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
示例
输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
```

- 题解1 ，优先队列先排序，然后每次取出2个，比较完，扔进去，最后返回即可

## 二分法

### 二分模板，只需要记住这一个即可

记住循环条件是l<r，而且返回结果不管是L还是R都是可以的

```java
  public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (target > nums[len - 1]) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return right;
    }
```

###  求山峰数组最高点索引值

[题目地址](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)



在一个山峰数组中，只有3种情况

- 第一种：当前值的大于左边的
- 第二种：当前值的小于左边的
- 第三种：当前值大于左边的，而且大于右边的

```java
    public int peakIndexInMountainArray(int[] arr) {
             int len = arr.length;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1]) {
                return mid;
            }else if(arr[mid]>arr[mid-1]){
                left=mid+1;
            }else if(arr[mid]<arr[mid-1]){
                right=mid;
            }else {
               // System.out.println("这个根本不会进入");
            }
        }
        //这里随便return，因为肯定会返回
        return -1;
    }
```

### 求X的平方根

力扣69题

```
  public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (target > nums[len - 1]) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return right;
    }
```



## 优先队列

### 合并K个有序链表

```java
  public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> pq = new PriorityQueue<>((v1, v2) -> v1.val - v2.val);
        for (ListNode node: lists) {
            if (node != null) {
                pq.offer(node);
            }
        }

        ListNode dummyHead = new ListNode(0);
        ListNode tail = dummyHead;
        while (!pq.isEmpty()) {
            ListNode minNode = pq.poll();
            tail.next = minNode;
            tail = minNode;
            if (minNode.next != null) {
                pq.offer(minNode.next);
            }
        }

        return dummyHead.next;
    } 
```

### 最小栈

用2个栈实现，原理很好理解，每次放入栈的时候，往另一个栈放入最小的数据，出栈的时候，两个栈都出

- 方法一：2个栈实现

```java
import java.util.Stack;

/**
 * @author xiyou
 * @version 1.0
 * xiyou-todo 最小栈的实现
 * @date 2020/5/12 15:30
 */
class MinStack {

    Stack<Integer> origin=new Stack<>();
    Stack<Integer> min=new Stack<>();
    /** initialize your data structure here. */
    public MinStack() {

    }

    public void push(int x) {
        origin.push(x);
        if(min.size()==0){
            min.push(x);
        }else {
            if(x>min.peek()){
                min.push(min.peek());
            }else {
                min.push(x);
            }
        }
    }

    public void pop() {
        if(origin.size()>0){
            origin.pop();
            min.pop();
        }
    }

    public int top() {
        if(origin.size()>0){
            return origin.peek();
        }else {
           throw  new RuntimeException();
        }
    }

    public int getMin() {
        if(origin.size()>0){
            return min.peek();
        }else {
            throw  new RuntimeException();
        }
    }
}
```

- 方法二：两个栈实现，但是第二个栈，不存放过多的数据

比如数据是`3，2，1，1，1  3 ，6` 所以最小栈是`3，2，1，1，1 ，1，1`

但是都说方法二了，肯定是要简化的，简化就是去掉3和6代表的1，但是本身的1不要去掉变成`3，2，1，1，1`

```

public void push(int x) {
        origin.push(x);
        if (min.size() == 0) {
            min.push(x);
        } else {
            if (x <= min.peek()) {
                min.push(x);
            }
        }
    }

    public void pop() {
        if (origin.size() > 0) {
            if ( origin.peek().intValue()==min.peek().intValue()) {
                min.pop();
            }
            origin.pop();
        }
    }
```

这个方法其实省去了很多的内存，假如1后面有100个元素都大于1，那么其实都不用存储了，但是这个相同的1暂时还没有方法去掉

- 方法三：一个栈

最简单的是push和pop的时候放入2个元素，一个是当前元素，一个是最小值，这样2个栈变成单个栈，但是内存翻一倍，不推荐

- 方法四：一个栈，但是存放对象，如下：

```java
class MinStack {

    private Stack<Node> stack;

    public MinStack() {
        stack = new Stack<>();
    }
    
    public void push(int x) {
        // 将元素值 x 和 当前最小值 同时入栈。
        if (stack.isEmpty()) {
            stack.push(new Node(x, x));
        } else {
            stack.push(new Node(x, Math.min(x, stack.peek().min)));
        }
    }
    
    public void pop() {
        stack.pop();
    }
    
    public int top() {
        // 返回栈顶元素中的元素值。
        return stack.peek().val;
    }
    
    public int getMin() {
        // 返回栈顶元素的最小值
        return stack.peek().min;
    }

    private static class Node {
        int val;
        int min;

        public Node(int val, int min) {
            this.val = val;
            this.min = min;
        }
    }
}
```

- 方法四：不用栈，原生Node链表实现

```java
class MinStack2 {

    private Node head;

    public MinStack2() {}

    public void push(int x) {
        // 新建节点插入链表头部，作为新的头节点，存储当前的元素值和最小值，并且指向之前的头节点。
        if (head == null) {
            head = new Node(x, x);
        } else {
            head = new Node(x, Math.min(x, head.min), head);
        }
    }

    public void pop() {
        // 删除链表头节点
        head = head.next;
    }

    public int top() {
        // 返回头节点中存储的元素值
        return head.val;
    }

    public int getMin() {
        // 返回头节点中存储的最小值
        return head.min;
    }


    class Node {
        int val;
        int min ;
        Node next;

        public Node(int val, int min) {
            this.val = val;
            this.min = min;
        }

        public Node(int val, int min, Node next) {
            this.val = val;
            this.min = min;
            this.next = next;
        }
    }
}
```




## MCVV

### 0. MVCC 连环问答

- MVCC是什么？多版本并发控制

- MVCC怎么实现的？

  - 有一个列作为版本标识

- Mysql的MVCC和MVCC有何区别？

  - MySQL的MVCC并不是真正意义上的MVCC，MySQL其实还用了排它锁,因为修改的时候，会锁定当前记录
  - 所以MySQL的mvcc不仅仅单纯是乐观锁，还有悲观锁

- 原理是什么？

  - 普通MVCC：原理就是一个版本标识字段
  - Mysql MVCC ：
    1. 版本标识字段：最新更新成功的事务id、undo log回滚事务id、回滚标识
    2. 悲观锁中的排它锁

- 作用是什么？

  - 读不加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力；
  - 借助MVCC，数据库可以实现RC（提交读），RR（可重复读）等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本。保证了ACID中的I特性（隔离性）

- 当前读是什么？

  - 当前读即加锁读，读取记录的最新版本号，会加锁保证其他并发事物不能修改当前记录，直至释放锁。

  - 插入insert /更新update /删除delete操作默认使用当前读
  - 显示的为select语句加lock in share mode或for update的查询也采用当前读模式

- 快照读如何理解？

  快照读：不加锁，读取记录的快照版本，而非最新版本，使用MVCC机制，最大的好处是读取不需要加锁，读写不冲突

- 当前读和快照读有何区别？同上

- MVCC 与隔离级别的关系

  - mysql中MVCC只能实现RC RR其它的隔离级别不兼容
- 提交读（RC）：事务开始，读取最新的已经被修改了的记录，事务中也是读取最新的已经被修改了的记录
  
  - 可重复读（RR）：事务开始，读取最新的已经被修改了的记录,作为本事务的记录仓库A，然后本事务内的所有提交都是基于当前事务的记录仓库A进行修改，所有的修改作为一个**链存储**
## MySql事物和快照的关系
### MVCC事物开启必然会生成事物ID吗

对于mysql的提交读和可重读读级别下，下面有几个问题

- 当我用begin开启一个session的时候，必然会生成一个事物ID吗？
  - 答案：false，开启只是开启了一个会话而已，并不会真的生成事物ID
- 不执行增删改查会生成事物ID？
  - 答案：false不会，
- 什么时候才会生成事物ID？
  - 增删改查，也就是有一条语句被执行后才会生成一个事物ID

### 验证mysql begin会开启事物吗？

- 打开两个窗口AB，在RR级别下，分别执行begin语句

```mysql
mysql> begin;
Query OK, 0 rows affected (0.01 sec)
```

- 然后查询,发现是空的，也就是当前还没有出现事物

```mysql
mysql>  select * from information_schema.INNODB_TRX;
Empty set
 
```

- A执行查询

```mysql
mysql> select * from test;
+----+--------------+
| id | name         |
+----+--------------+
|  1 | how are you2 |
|  2 | 124          |
|  3 | wanwa        |
|  4 | wanwa        |
| 45 | wanwa        |
+----+--------------+
5 rows in set (0.02 sec)
```

- A执行完，执行事物查询,发现已经生成了一个事物记录，B再次执行查询，发现记录变为2条

```java
mysql>  select * from information_schema.INNODB_TRX;
+-----------------+-----------+---------------------+-----------------------+------------------+------------+---------------------+-----------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+
| trx_id          | trx_state | trx_started         | trx_requested_lock_id | trx_wait_started | trx_weight | trx_mysql_thread_id | trx_query | trx_operation_state | trx_tables_in_use | trx_tables_locked | trx_lock_structs | trx_lock_memory_bytes | trx_rows_locked | trx_rows_modified | trx_concurrency_tickets | trx_isolation_level | trx_unique_checks | trx_foreign_key_checks | trx_last_foreign_key_error | trx_adaptive_hash_latched | trx_adaptive_hash_timeout | trx_is_read_only | trx_autocommit_non_locking |
+-----------------+-----------+---------------------+-----------------------+------------------+------------+---------------------+-----------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+
| 283814052109728 | RUNNING   | 2020-06-25 21:54:59 | NULL                  | NULL             |          0 |              135838 | NULL      | NULL                |                 0 |                 0 |                0 |                  1136 |               0 |                 0 |                       0 | REPEATABLE READ     |                 1 |                      1 | NULL                       |                         0 |                         0 |                0 |                          0 |
+-----------------+-----------+---------------------+-----------------------+------------------+------------+---------------------+-----------+---------------------+-------------------+-------------------+------------------+-----------------------+-----------------+-------------------+-------------------------+---------------------+-------------------+------------------------+----------------------------+---------------------------+---------------------------+------------------+----------------------------+
1 row in set (0.02 sec)
 
```

- 结论如下：在执行begin的时候，虽然不会直接生成事物ID，但是如果我们进行了任何的CRUD操作，都会出现事物的记录，也就是产生了事物的ID

### MVCC快照ReadView是在什么时候生成的？

- 上面说了事物在开启的时候必然会生成事物ID！那么开启事物的下一刻就会生成快照ReadView吗？
- 什么时候会生成快照ReadView？
- 生成一次快照后，能再次生成吗？

针对以上的问题，我们来依次解答！

1. 开启事物执行了CURD操作必然会生成事物ID，但是不一定马上生成快照ReadView
2. 当我们第一次执行查询的时候，才会生成一个针对整个数据库ReadView
3. 如果不是查询语句，则不会生成快照ReadView，比如update、delete、insert语句都不会生成一个快照
4. 生成一次快照后，如果是RR（可重复读），则除了自己修改的数据外，其它数据保持不变，因为要维持可重复读；如果是RC（不可重复读），则在每一次select的时候会重新生成一个快照
5. RR第一次生成快照的时候，并不是查询比当前事物ID小的数据，而是查询已经commit之后的最新数据，可能会包含一个事物开启的比自己还晚的数据

### 验证事物第一次查询才生成快照，而且是已经提交数据的最新快照

- 先后开启两个session不进行任何操作

```mysql
##事物B先开启
mysql> begin;
Query OK, 0 rows affected (0.01 sec)
```

```mysql
##事物A后开启
mysql> begin;
Query OK, 0 rows affected (0.01 sec)
```

- 然后事物A修改一条数据，之后直接commit

```mysql
## 事物A
mysql> select * from test;
+----+----------+
| id | name     |
+----+----------+
|  1 | xiyouyan |
|  2 | 124      |
|  3 | wanwa    |
|  4 | wanwa    |
| 45 | wanwa    |
+----+----------+
5 rows in set (0.02 sec)
 
mysql> update test set name ="how are you" where id =1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0
 
mysql> commit;
Query OK, 0 rows affected (0.02 sec)
```

- 事物B这个时候查询？

```mysql
## 事物B查询
mysql> select * from test;
+----+-------------+
| id | name        |
+----+-------------+
|  1 | how are you |
|  2 | 124         |
|  3 | wanwa       |
|  4 | wanwa       |
| 45 | wanwa       |
+----+-------------+
5 rows in set (0.01 sec)
```

- 结论就是：事物的开启可以有先后顺序，但是查询的时候才会去生成快照，并不是事物开启的时候生成快照
- 而且生成的快照是基于数据库最新已经提交的数据

如果你对这个结果不是很信服，比较B在Acommit之前什么也没有做！那么我们先让B执行一个update语句，然后开始事物A，A修改语句，然后提交，这个时候B再查询，看看能看到A的数据不？

```mysql
## 事物B开启并修改记录
mysql> begin;
Query OK, 0 rows affected (0.02 sec)
 
mysql> update test set name ="how are you22" where id =3;
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

- 切换事物A，直接修改记录并提交

```mysql
mysql> begin;
Query OK, 0 rows affected (0.02 sec)
 
mysql> update test set name="sxx" where id =4;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0
 
mysql> commit;
Query OK, 0 rows affected (0.02 sec)
```

- 切换回事物B，执行查询，如果出现A的结果，则说明快照读是只有查询的时候才会产生，而且查询的是数据库最新已经被提交了的数据

```mysql
mysql> select * from test;
+----+---------------+
| id | name          |
+----+---------------+
|  1 | how are you22 |
|  2 | 222           |
|  3 | how are you22 |
|  4 | sxx           |
| 45 | wanwa         |
+----+---------------+
5 rows in set (0.02 sec)
```

- 我们发现ID=4的记录已经被修改成了sxx，说明我们的验证成立

## MySql 快照ReadView

快照读可以简单的理解为：当查询的时候，直接读数据库已经提交了的最新版本，不管当前提交的事物是不是早于当前事物执行，只要查询的时候，其它事物提交了，快照读就能获取到。

- 为啥要获取已经提交了的数据，而不是早于当前事物前被提交了的数据？
  - 因为提交读本身就是要获取已经提交了的数据，不然就变成了别人都提交了你都获取不到

当在事物中，执行查询的时候，会生成一个ReadView，它由所有未提交的事物ID数据和已创建的最大事物ID组成的版本链，然后取数据的时候进行数据的对比

ReadView=（未提交事物ID列表）+（已创建的最大事物ID）



比如先后开启ABCD Q五个事物，他们的事物时间线是这样的。

| 事物A    | 事物B    | 事物C           | 事物D    | 事物Q  | 时刻 |
| -------- | -------- | --------------- | -------- | ------ | ---- |
| Update=1 |          |                 |          |        | T0   |
|          | Update=2 |                 |          |        | T1   |
|          |          | Update-commit=3 |          |        | T2   |
|          |          |                 | Update=4 |        | T3   |
| update=5 |          |                 |          | Read_A | T4   |
| Commit   |          |                 | update=6 |        | T5   |
|          | Commit   |                 |          |        | T6   |
|          |          |                 |          | Read_B | T7   |

这里面D是最大的事物ID，那么请问Q查询的时候，能查询到哪些数据？

> ReadView=（未提交事物ID列表）+（已创建的最大事物ID）
>
> 所以大体可以分为2部分：已经提交的部分、未提交的部分

### 快照读的对比规则实现

- Read_A时刻，未提交的事物数组是：【ABD】最大事物ID是D

- 而当前的Read_A时刻的版本链是：xx——1——2——3——4
  - 我们最先读到的是4，发现在未提交数组里面，则向下寻找
  - 寻找到3，发现不在数组里面，说明已经提交，直接获取
  - 最后数据就是：3



- Read_B时刻，未提交数据的数组是D，最大事物ID也是D，但是这样理解是错误的
- Read_B时刻不再生成新的readview数组，沿用Read_A的，所以还是【ABD】最大为D
- Read_B时刻的版本链是：xx——1——2——3——4——5——6
- 所以最先找到D，发现在未提交里面，放弃，向下寻找，同样54也是放弃
- 最后结果还是3

### 回滚的实现

假如上面的表格中，事物B在T4发生回滚，回滚操作在C事物提交之后，请问回滚数据是要回滚到哪？最初的xx状态还是事物C提交后的状态？

答案：事物C提交后的状态

- 因为当前的版本链路是：xx——1——2（自己修改）——3（提交）——4——5
- 所以它会从最新的版本链路向前寻找到自己修改的数据，找到自己修改数据的回滚指针，如果中间已经有被提交了的，则终止寻找，回滚
- 上面就会找到3，然后回滚


## 1.MySQL MVCC具体实现

- 1.1 隐藏列
  mysql在行都设置了默认列（对查询不可见），包含有 data_trx_id、data_roll_ptr、db_row_id、delete bit

  - db_row_id是在用户没设置聚集索引保留
  - delete bit 删除标志
  - data_trx_id 最近更新或创建 这条记录的 事务id
  - data_roll_ptr 回滚指针（也称之为删除事务id，在事务中查找查找上个版本的记录就靠这个指针，指向了undo log的地址，可以把同一个事务中的多个版本理解为链式关系）
- mysql利用最新更新成功的事务id、和回滚事务id实现MVCC
  
  - 事务id分为三种：当前事务id、最新更新成功的事务id、历史最晚事务id
- 事务

  - 最晚事务id>当前事务ID >最新更新成功事务id
  - 原理是：undo log,每次修改其实都是在一个链路上进行的，
  

（说明你A可能是先进来的,获取的数据版本是V0，但你不是最先修改该记录的人。

当前记录已经被其它人B修改成功，版本变成了V1，但是如果你修改值的话，你修改的结果将成为最新的数据，成为V2版本，回滚的时候也不会回滚到你获取数据的那个版本V0，而是回滚的结果是已经被修改的数据的版本V1）

  为啥回滚的时候，不会回滚成原来的V0版本？

​	比如A进来查询的时候，数据上V0，别人修改了变成了V1，但是其实他是看不到V1的，但是为啥回滚的时候居然回滚成了V1呢？可以简单的理解为：你只能回滚自己的操作，但是别人已经提交了的数据你是不能回滚的，不然别人就白提交了

因为undo log机制，undo log其实就是在你进行任何增删改（不包括查询）之前，记录数据库的最新记录undo log，然后回滚的时候直接用

  - 当前事务事务id>历史最晚事务id（说明你这个事务才是最晚的，才新建的事务，还没有被记录）所以可以直接从数据库获取最新的数据
  
  - 当前事务事务id<最新更新成功事务id（不存在）
- MySQ排它锁具体实现流程：
  - 事务排它锁修改数据（就是说在RC或者RR级别下，如果一个事务A正在修改一个记录，其它事务B不能修改，只能等A提交或者回滚之后才能修改）
  - 修改完之后，更新隐藏字段的事务id为当前事务id， 记录undo log ，并且把回滚指针指向上一个版本的地址
  - 成功了说明都不做，失败了从undo log 回滚

## 2. CAS与mysql MVCC的区别

 比如说id=1的记录，name是A

- CAS：可以理解为我在修改前查询id=1的记录name否是原来的值A,如果是则更新，不是的话则自旋
  - CAS所以会出现ABA的问题（B把记录修改成C，C把记录再修改成A，那么A就认为它修改的时候记录没有被其它值修改，然后它修改了），具体请查看CAS讲解
- mysql MVCC 的修改是利用的行锁，是悲观锁，自己在修改的过程中，除非自己提交了事务（不管修改后的值有没有被其它事务看到），否则其它事务都不能进行修改


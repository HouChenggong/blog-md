MySQL事务

#  ACID 

![](E:\2020\code\springboot_dubbo\tools\md\mysql\img\ACID.png)

## 1、redo log 和undo log

 ![](E:\2020\code\springboot_dubbo\tools\md\mysql\img\原子性实现undolog.png)

#### 正常事务的执行流程

修改一条记录的顺序是：如把id为1的记录的age=1修改成2

```css
1. 事务A 开始
2. undo 记录原来的值1，也可以理解为update set age=1 where id =1
3.执行update语句
4.记录redo log age=2
5. 将redo log 写入磁盘
6. 事务提交，将数据写入磁盘
7.事务结束
```

##### redolog和事务谁优先写入磁盘数据？

其中，redo日志必须先于数据写入磁盘（即步骤5和步骤6的顺序不能改变）。因为如果不这样，在数据提交之后再写redo日志，一旦redo日志的写入过程出现异常，将无法保证持久性。

记录redo日志时，先记入redo log buffer，最后再一起写入磁盘，这样可以减少IO，提升性能。

另外，未提交的事务和回滚了的事务也会计入redo日志。

#### 回滚的事务提交过程

```
1. 事务A 开始
2. undo 记录原来的值1，也可以理解为update set age=1 where id =1
3.执行update语句
4.记录redo log age=2
---- 这时出现异常回滚
+1 将age修改回1
+2记录 redo log
-----
5. 将redo log 写入磁盘
6. 事务提交，将数据写入磁盘
7.事务结束
```

回滚提交的事务，首先会根据先后顺序的逆序把值改回原来的，然后再记录redo log，其实就是多了这两步操作

#### checkpoint机制

redo日志会随着时间推移而越来越大，为了提升redo的恢复性能，引入了**checkpoint机制**，在恢复的时候，只需要从checkpoint的位置往后恢复即可。

------

#### MySQL恢复策略

mysql的恢复策略是：

1. 恢复时，先根据**redo**重做所有事务（包括未提交和回滚了的）
2. 再根据**undo**回滚未提交的事务。

比如上面事务A未提交事务的时候宕机，恢复时，先根据redo日志将数据恢复为age=2，然后根据undolog 把记录变成age=1恢复如初

事务B也是提交事务的时候宕机，恢复时根据redo日志，可以直接恢复至`age=1`的初始状态。







可重复读：读的是事务开始数据快照的状态

不可重复读:读的是最新数据持久化的状态

## 幻读：

和其它不一样的是，是针对增删而言的，

```
1. 事务A 开始 事务B 开始
2. 事务A插入id=5的记录
	此时事务B是无法看到id=5的记录	
3. 事务B再次插入id=5的记录
	这个时候事务B会发生阻塞，卡死不能进行任何操作，直到事务A提交为止
4. 事务A提交
	此时事务B阻塞完成，但是这个时候他插入id=5的记录就会报错，如下：
	1062 - Duplicate entry '5' for key 'PRIMARY'
而且此时他再查询数据库，还是看不到id=5的记录，所以对他而言，就好像幻觉一样，id=5的记录没有却插入不了
5.事务B错误回滚，在整个过程中他都看不到id=5的记录已经被插入了
```

所以 mysql 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。

#### 不是说mysql的重复读解决了幻读的么？

MySQL的解读是：当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。

那么InnoDB默认对一个普通的查询也会加next-key locks吗，还是说需要应用自己来加锁呢？如果单看这一句，可能会以为InnoDB对普通的查询也加了锁，如果是，那和序列化（SERIALIZABLE）的区别又在哪里呢？

我们用下面的例子来理解：

```sql
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```

### 解决幻读

#### **1. 避免幻读可以select锁住，再insert**

```sql

比如上诉的例子中，如果我们要插入id=5，num=1000的记录，那么我们可以在A事务开始之前把它锁住，如下：

1. 事务A 开始 事务B 开始
+1.1 事务A执行 SELECT * FROM test WHERE num=1000 FOR UPDATE;
	假设数据库中没有num记录是1000的，也就是事务A执行上一条语句的返回是null，如下：
	mysql> select * from test where num =1000 for update;
	Empty set
	猜想这个时候B事务在A事务插入前插入是否成功？答案是否定的
	事务B要么超时回滚事务，要么一直等待事务A提交，也就是说不管事务A是否锁住了真实的已有记录，事务B都是要阻塞大的，接下来就和上面的一样了
	
2. 事务A插入id=5的记录
	此时事务B是无法看到id=5的记录	
3. 事务B再次插入id=5的记录
	这个时候事务B会发生阻塞，卡死不能进行任何操作，直到事务A提交为止
4. 事务A提交
	此时事务B阻塞完成，但是这个时候他插入id=5的记录就会报错，如下：
	1062 - Duplicate entry '5' for key 'PRIMARY'
而且此时他再查询数据库，还是看不到id=5的记录，所以对他而言，就好像幻觉一样，id=5的记录没有却插入不了
5.事务B错误回滚，在整个过程中他都看不到id=5的记录已经被插入了
```

#####   普通字段for update  时候  有无数据都会锁住整个表 

```
还是上面的数据，我们确保数据库没有num =1000的记录，执行下面的操作

1. 事务A 开始 事务B 开始
+1.1 事务A执行 SELECT * FROM test WHERE num=1000 FOR UPDATE;
	假设数据库中没有num记录是1000的，也就是事务A执行上一条语句的返回是null，如下：
	mysql> select * from test where num =1000 for update;
	Empty set
	 这个时候事务B肯定是插入不了num=1000的记录的，但是事务B能否插入普通的数据呢？比如插入id=15,num=15的记录，下面我们测试一下
 
2. 事务B插入id=15 num=15的记录
	这个时候事务B也会发生阻塞，卡死不能进行任何操作，直到事务A提交为止，这就说明了上诉的结论
	如果for update  时候，id为主键，RR策略时候，锁住了的条件符合的行，但是如果条件找不到任何列，锁住的是整个表
	
4. 事务A提交
	此时事务B阻塞完成，但是这个时候他才能插入id=15的记录
5.事务B提交，插入完成id=15的记录
```

同理我们还可以测试，数据库中有1条记录是Num=15,这个时候我们插入id=16，num=15的记录是否是可以的呢？

答案出乎你的意料：也是不可以的，因为我们的test表只有一个主键，num是普通字段，当我们

select * from test where num =15 for update的时候，实际是通过主键查询到的，这个时候就会锁住全部的数据

同理插入 id=16 num =16也是不行的，原因和上面一样

所以有人就会问？如果是普通字段，for update的时候，会不会把整个表锁住，其实是这里分两种情况

1. **就是上面说的，只有一条记录是num=15,锁住整个表**

2. num=15对应了多个数据，也是锁住了整个表

3. 没有记录是num=15锁住的也是整个表

#####  for update 对于主键字段呢？

我们理解的是主键其实对应的是主键索引，所以当for update 没有数据时，没有锁

for update 锁住了1-N条数据时，锁住的是对应的1-N条记录和1至N条记录对应的主键索引，其它记录依旧可以操作

```sql
比如这个：锁住的其实是id=1的字段
mysql> select * from test where id =1 for update;
+----+-----+
| id | num |
+----+-----+
|  1 |  11 |
+----+-----+
1 row in set (0.04 sec)
按照我们的理解我们不能对id=1的数据进行增删改，但是可以对其它数据增删改
实际执行情况是：
  update test set num=1 where id=1; 阻塞
  其它的id不是1的都可以操作
  
```

##### for update 对于普通索引字段

根主键字段 一样，只会锁住索引的记录，如果索引没有匹配到记录，则无锁



结论：

```
普通字段update不管是否匹配到数据，锁住全部
主键和索引如果没有匹配到记录，无锁。如果匹配到了，只锁匹配到的
一个主键和一个普通字段，匹配到数据是行锁，匹配不到是无锁

```







####  2.SELECT * FROM xxx LOCK IN SHARE MODE;会在本事务内读取最新的记录

包括其它事务提交的数据，所以破坏了可重复读的原则




结论：mysql 的重复读解决了幻读的现象，但是需要 加上 select for update/lock in share mode 变成当前读避免幻读，普通读select存在幻读**

但是重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。






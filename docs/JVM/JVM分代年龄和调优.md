### 可达性算法

GC Root 可以作为根的是：本地变量、静态变量、本地方法栈等

![](E:\2020\code\springboot_dubbo\tools\md\JVM\img\堆的分代.png)

## minor GC

第一阶段：Eden到From区

1. new出的对象放到Eden（伊甸园区）
2. 一个堆默认600M，年轻代200M(Eden占80%160M，其它都是20M)，老年代400M
3. 如果Eden放满了，就要开始垃圾收集GC
4. 利用可达性算法GCroot根，找到垃圾对象，利用复制算法，把不是垃圾的对象复制到From区，垃圾的对象直接删除
5. 如果对象从Eden被复制到了From区，对象头的分代年龄+1

第二阶段：

1. 回收Eden 和From 区，Eden和From区的存活对象直接复制移动到To区，也就是说可以直接从Eden到To区，对象年龄+1,当前From为空
2. 如果Eden区又满了，这次就会把eden和to区的存活对象放到上次空的From区，对象年龄+1
3. 如此往复
4. 年龄大于15，直接放到老年代

### 老年代都有哪些数据？

##### 1. 单例、静态对象、线程池对象、Session、Spring的Bean 



#####  2.大对象直接进入老年代



```java
比如需要大量连续内存空间的对象，字符串和数组

java参数  -XX：PretenureSizeThreshold可以设置大对象大小，如果超过设置大小直接进入老年代，不会进入年轻代，但是只在Serial和ParNew两个垃圾收集器中有效

比如：`-XX:PretenureSizeThreshold=1000000 -XX:+UserSerialGC`

再创建的对象就会直接进入老年代
```

##### 3. 长期存活的对象进入老年代**

而且可以设置年龄值，默认15  `-XX:MaxTenuringThreshold`

##### 4 动态年龄判断

```
如果一批对象的大小超过了Surivor内存大小的50%（-XX：TargetSuriviorRatio可以设定大小）
此时大于等于这批对象里面年龄最大的对象将直接进入老年代
比如Survior里面有一批对象年龄未1，2，..n总和超过50%，此时就会把>=N的直接放入老年代
```

##### 5.MinorGC后存活的对象Surivor区放不下

这种情况，会把存活的对象直接放入老年代，部分可能还会再Surivor区

##### 6. 老年代空间分配担保机制

年轻代每次MinitorGC之前都会计算老年代剩余空间，如果剩余空间小于年轻代里面所有对象之和（包括垃圾对象），就会看看是否设置了-XX:HandlePromotionFailure参数（JKD默认设置），如果有则看看老年代剩余内存大小是否大于之前每一次MinorGC之后进入老年代的平均大小，如果如果小于或者参数没有设置，则触发Full GC,对老年代和年轻代一起进行垃圾回收，如果回收完还是空间不够存储新的对象，就会发生OOM







### 老年代被放满之后？怎么办？

FULL GC

## Full GC 

而且FullGC 主要是Java调优要调节的内容，minorGC如果特别频繁也要调节

调优的目的就是减少FULLGC 或者minorGC的次数



Java VisualVM安装 Visual GC

#### 模拟并发

1. 假如秒杀的时候，每秒产生300个订单，一个订单对象大概1K，放大20倍，每秒大概300K*20=6M数据，但是1秒之后就会变成垃圾数据，如果再加上查询订单，那就是每秒60M数据

2. 假设Eden区600M数据，那么10秒之后Eden就满了，开始monitorGC，此时系统还有订单过来，也就是在回收的时候其实600数据里面至少有60M数据不是垃圾对象，那么这60M对象对应的线程就会阻塞，影响这60M对象对应线程的用户体验


#### Stop the world

无论是Ful GC 还是Minor GC都会stop the world

为啥需要stop the world

因为如果不停止，假设在做GC的时候，一个线程还没有执行完，所以对象都不是垃圾，当执行完了对象就变成了垃圾，所以刚开始GC手机的对象就会不准确



### 秒杀如何调优

1. 年轻代内存调大些，保证第二次monitorGC的时候，前一次没有被清理的对象被标记为垃圾对象


[可以参考这个，里面有代码示例](https://blog.csdn.net/qq_39455116/article/details/86743045)

内存泄漏指你用malloc或new申请了一块内存，但是没有通过free或delete将内存释放，导致这块内存一直处于占用状态。
​	
内存溢出指你申请了10个字节的空间，但是你在这个空间写入11或以上字节的数据，就是溢出。

## 1. 内存溢出 out of memory
​	是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；

### 1.1 常见的内存溢出分为以下几种： 
#### 1- Java堆溢出 

> Java 堆用于存储对象实例，只要不断地创建对象，并且保证垃圾回收机制清除这些对象，那么在对象数量达到最大堆限制就会产生内存溢出异常。
>
> 测试方案：无限循环new对象实例出来，在List中保存引用，防止GC回收，最终会产生OOM ,异常堆栈信息并提示Java heap space。

#### 2 虚拟机栈和本地方法栈溢出 

> 关于虚拟机栈和本地方法栈，Java虚拟机规范中定义了两种异常： 
> 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError 异常。 
> 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

测试方案： 单线程条件下，通过不断递归调用方法，如不断累加的方法，如下所示：

    public class JavaVMStackSOF{
        private int stackLength=1;
        public void stackLeak(){
            stackLength++;//累加变量
            stackLeak();//调用自身
        }
    } 

最终会产生StackOverflowError栈溢出异常；

多线程条件下，无限循环地创建线程，并为每个线程无限循环的增加内存，最终会导致OutOfMemoryError异常。
3 方法区和运行时常量池溢出 
 运行时常量池是方法区的一部分。方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等。测试方法： 
（1）对于非常量池部分，运行时生成大量的动态类填满方法区; 
（2）对于常量池部分，无限循环调用String的intern()方法产生不同的String对象实例，并在List中保存其引用，以防止被GC回收，最终会产生溢出

 


##  2. 内存泄露 memory leak
	 是指程序在申请内存后，无法释放已申请的内存空间 
	 memory leak会最终会导致out of memory！
###   2.1 内存泄漏分类
1.  常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 
2.  偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 
3.  一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 
4.  隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 

5.  从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 

### 2.2 内存泄漏引起的原因
	内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存
	得不到及时释放，从而造成的内存空间的浪费称为内存泄露。

### 2.3  	Java内存泄露根本原因是什么呢？
   长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，
   尽管短生命周期对象已经不再需要，但是因为
​           **长生命周期对象持有它的引用而导致不能被回收**
​           这就是java中内存泄露的发生场景。具体主要有如下几大类：




 #### 1、静态集合类引起内存泄露： 

> 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着

```
static Vector v = new Vector(10);
for (int i = 1; i<100; i++)
{
Object o = new Object();
v.add(o);
o = null;
}//
```

> 在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector
> ​     中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC
> ​     来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector
> ​     中删除，最简单的方法就是将Vector对象设置为null。

####  2、当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。


**前提是Person类要重写equirs()和hashCode()方法**

```
public static void main(String[] args)
{
Set<Person> set = new HashSet<Person>();
Person p1 = new Person("唐僧","pwd1",25);
Person p2 = new Person("孙悟空","pwd2",26);
Person p3 = new Person("猪八戒","pwd3",27);
set.add(p1);
set.add(p2);
set.add(p3);
System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素!
p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变

set.remove(p3); //此时remove不掉，造成内存泄漏

set.add(p3); //重新添加，居然添加成功
System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素!
for (Person person : set)
{
System.out.println(person);
}
}
```


### Q: 如何避免内存泄露、溢出？ 
 A: 1)尽早释放无用对象的引用。

好的办法是使用临时变量的时候，让引用变量在退出活动域后自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄露。

2)程序进行字符串处理时，尽量避免使用String，而应使用StringBuffer。

3) 尽量少用静态变量。

因为静态变量是全局的，GC不会回收。

4)避免集中创建对象尤其是大对象，如果可以的话尽量使用流操作。

5)尽量运用对象池技术以提高系统性能。

生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏，例如大集合对象拥有大数据量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。

6)不要在经常调用的方法中创建对象，尤其是忌讳在循环中创建对象。

可以适当的使用hashtable，vector创建一组对象容器，然后从容器中去取那些对象，而不用每次new之后又丢弃。

 
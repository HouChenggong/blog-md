### 线程池相关

两个方法都可以向线程池提交任务，execute()方法的返回类型是 void，它定义在Executor 接口中。

而 submit()方法可以返回持有计算结果的 Future 对象，它定义在ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。

https://www.jianshu.com/p/40e8f4ccc796



当一个线程池里面的线程异常后:执行方式是execute时,可以看到堆栈异常的输出。当执行方式是submit时,堆栈异常没有输出。但是调用Future.get()方法时，可以捕获到异常。不会影响线程池里面其他线程的正常执行。线程池会把这个线程移除掉，并创建一个新的线程放到线程池中。

 

### submit() 方法提交任务没有异常抛出的原因。

```java
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    // 被包装成 RunnableFuture 对象，然后准备添加到工作队列
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}
```

它会被线程池包装成 RunnableFuture 对象，而最终它其实是一个 FutureTask 对象，在被添加到线程池的工作队列，然后调用 start() 方法后， FutureTask 对象的 run() 方法开始运行，即本任务开始执行。

```java
public void run() {
    if (state != NEW || !UNSAFE.compareAndSwapObject(this,runnerOffset,null, Thread.currentThread()))
        return;
    try {
        Callable<V> c = callable;
        if (c != null && state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                // 捕获子任务中的异常
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        runner = null;
        int s = state;
        if (s >= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
```

在 FutureTask 对象的 run() 方法中，该任务抛出的异常被捕获，然后在setException(ex); 方法中，抛出的异常会被放到 outcome 对象中，这个对象就是 submit() 方法会返回的 FutureTask 对象执行 get() 方法得到的结果。

但是在线程池中，并没有获取执行子线程的结果，所以异常也就没有被抛出来，即被“吞掉”了。

### try catch 相关

当catch和finally都有返回的时候，执行finally返回

https://blog.csdn.net/qq_39455116/article/details/87880574

### 线程池自定义异常处理

https://mp.weixin.qq.com/s/TQGtNpPiTypeKd5kUnfxEw

### final关键字

关键字主要用在三个地方：变量、方法、类。

1. 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。
3. 当final修饰方法时，方法不能被重写

### MCVV和事务



### RDB和AOF以及AOF重写



### 手写双向链表



### JDK8多线程并行



### IOC相关



### @Resouce和@Aut

@Autowire默认按照类型装配，默认情况下它要求依赖对象必须存在如果允许为null，可以设置它required属性为false，如果我们想使用按照名称装配，可以结合@Qualifier注解一起使用;


@Resource默认按照名称装配，当找不到与名称匹配的bean才会按照类型装配，可以通过name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象.

注意：如果没有指定name属性，并且按照默认的名称仍然找不到依赖的对象时候，会回退到按照类型装配，但一旦指定了name属性，就只能按照名称装配了.

### 索引

### 单例模式

### 消息的重复消费

### 过滤器、拦截器、监听器

- 过滤器
  - 通过过滤器过滤资源
  - 基于函数调用
  - 比如说SQL、XSS注入

```
public interface Filter {
	//容器初始化时调用一次
    void init(FilterConfig var1) throws ServletException;
	
    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;
	//容器销毁时调用一次
    void destroy();
}
```

- 拦截器
  - 基于反射机制

```
public interface HandlerInterceptor {
	// 在业务处理器处理请求之前被调用
    boolean preHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;
	//在业务处理器处理请求之后被调用
    void postHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4) throws Exception;
	//在DispatcherServlet完全处理完请求后被调用 
    void afterCompletion(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4) throws Exception;
}
```

- 监听器

```

```



### redis为啥快？

- 纯内存
- 单线程，避免频繁的上下文切换
- 非阻塞IO多路复用机制

### redis为啥可以用作分布式锁？

- 单线程

### 缓存击穿、穿透、雪崩

- 击穿：刚好过期

  - 发现不存在，添加分布式锁，加完锁之后，查询缓存，如果还不存在，查询数据库，然后写缓存，后面的用户再次查询缓存就会有缓存

    

- 缓存穿透：不存在的数据，恶意用户
  - 数据校验
  - 不聋过滤器

### 双写一致性

#### 先更新数据库，再更新缓存

- 会存在更新缓存失败的情况

#### 先删除缓存再更新数据库

线程A，更新，删除缓存

线程B，查询，发现缓存没有数据，就把旧的数据更新到缓存中

-  解决方案：
  - 先删除缓存，更新数据库
  - 然后程序睡眠3s，然后再次删除缓存，保证在休眠的这三秒，其它操作导致的插入缓存被删除
- 再次优化
  - 先删除缓存，更新数据库，然后休眠3s，然后异步删除
  - 但是会导致异步删除失败的情况

### 先更新数据库，再删除缓存

- 如果缓存删除失败了，则都是旧的值

#### 最终方案：队列

- 读写串行化到一个队列中，但是要化好几倍的机器来处理
- 但是队列也有数据锁历史数据的问题，所以还是采用先删除缓存，更新数据库锁，然后再次删除缓存的机制
- 或者删除（更新）缓存的时候添加分布式锁，让其它线程阻塞，但不上一个很好的解决方案

### hashMap 链表转换红黑树为啥是8？

- 为啥要转换？
  - 因为链表长度太长，遍历的复杂度是O（n ）
  - 而红黑树的插入、删除和遍历复杂度都是long(n)
- 为啥是8？
  - 因为根据hashMap的文档，简单解释一下，理想情况下，在随机哈希代码下，桶中的节点频率遵循
    泊松分布，文中给出了桶长度k的频率表。
    由频率表可以看出，桶的长度超过8的概率非常非常小

### 快排

### JVM调优

- CPU100% 
- 内存溢出、泄漏

### 设计模式

### 动态代理的实现

### park unpack  yield  Thread哪些静态方法

- yield

暂停当前执行的线程对象，并执行其他线程。这个暂停是会放弃CPU资源的，并且放弃CPU的时间不确定。
 让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。

```java
  //当前线程
  public static native Thread currentThread();
  //
      public static native void yield();
      
  public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
    
    
    public static int activeCount() {
        return currentThread().getThreadGroup().activeCount();
    }
    
     public static native boolean holdsLock(Object obj);
```

- yield和sleep的区别？
  - 都不会放弃锁
  - 都会暂停当前线程
  - 不同点：sleep可以指定休眠时间，而yield依赖CPU的时间片花粉

## 消息队列相关

- 为啥需要消息队列

  - 削峰
  - 异步
  - 解偶

  

  

  

### 消息队列模型

- rabbitMQ 队列模型
  - 每个消息只能被一个消费者消费
- Kafka、rocketMQ 发布订阅模型
  - 只有一个消费者的情况下和队列模型基本一致。

### 消息不丢失

- 生产者不丢失

  - 生产者-到Broker不丢失，需要做好try catch，不管是同步还是异步
  - 重试机制

  ```java
  生产者发送消息至Broker，需要处理Broker的响应，不论是同步还是异步发送消息，
  同步和异步回调都需要做好try-catch，妥善的处理响应，
  如果Broker返回写入失败等错误消息，需要重试发送。当多次发送失败需要作报警，日志记录等。
  
  这样就能保证在生产消息阶段消息不会丢失。
  ```

  

- 存储Broker的不丢失

  - Brocker需要刷盘之后，而不是写入缓存之后就算成功
  - 集群部署

- 消费不丢失

  - ac k机制

#### rabbitMQ 生产者不丢失处理Confirm

[传送门]([https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages?id=%e7%94%9f%e4%ba%a7%e8%80%85%e5%bc%84%e4%b8%a2%e4%ba%86%e6%95%b0%e6%8d%ae](https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages?id=生产者弄丢了数据))

- 事务机制
- Confirm 机制



#### rabbitMQ 持久化

持久化可以跟生产者那边的 `confirm` 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 `ack` 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 `ack` ，你也是可以自己重发的。



#### rabbitMQ消费者ACK机制

### 消息不重复消费

- 重复消费不可怕，可怕的是**怎么保证幂等性**

  - 比如唯一ID或者索引机制

  - 通过版本号的方式保证

    ```java
    update t1 set money = 150 where id = 1 and money = 100 and version =xxx;
    ```

    

  - 

### 如何保证高可用-集群



### 消息有序性

- 一个队列，一个消费者
- 一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。

### 如何防止消息堆积

- 临时用额外的机器去处理

### 如何处理MQ消息过期

- rabbitMQ 天然支持TTL
- 定时任务去处理

## ZAB协议

https://mp.weixin.qq.com/s/k0zAExTvMsrugCaNJxs7hQ



### mysql

- 索引相关
- bufferPool相关
- **MyISAM**和Innodb的区别
  - Innodb支持事物，支持MVCC，但是MyISAM不支持
  - MyISAM 是非聚集索引，数据和文件是分开的，而Innodb是聚集索引，但是二级索引指的是主键ID
  - 没有食物，就没有数据回滚的能力


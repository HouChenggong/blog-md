## 2020.4月

### 0418

#### 算法

- 力扣11，盛水最多的容器
核心思路是首尾双指针，因为盛水是短板效应，哪里短，指针就移动

- 力扣200 找出岛屿的数量
思路有两种，BFS、DFS

BFS就是找到岛屿，然后放入队列中，然后向岛屿的4个方向寻找岛屿，如果挨着，沉岛

DFS就是找到一个岛屿，然后递归它的4个方向

- 其它

### 0419

- 算法

[二叉树首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)



一致性hash算法和它在负载均衡中的应用，以及与redis集群的hashSlot区别

- 手写一个MySQL死锁
- redission实现分布式锁的细节

### 0420

- 算法

  [搜索旋转一次后的排序数组地址](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

给一个经过1次旋转的数组，找出所求的数，要求Log(n)级别的，解题思路是：二分法

### 0421 

- 算法

力扣1248滑动窗口求组合数量，思路是滑动窗口求解

而且每次组合数量=（奇数左边的偶数个数+1）*（奇数右边的偶数个数+1）

- Java锁消除、锁粗话、锁降级、锁升级
- JavaUnsafe类
- 简单工厂模式、多个工厂模式，静态工厂模式
  - 如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则
  - 解决方案是抽象工厂模式
- 抽象工厂模型
  - 就是每次增加一个功能只需要添加一个类去实现即可，但是很麻烦

- AQS简单理解



###  0422（有点偷懒）
- 算法 
  - 二叉树的左右视图

### 0423 

换硬币问题，比如给1，5，10，25四种零钱，有多少种方法兑换一个钱，比如说51，答案是49种

思路：数学等差队列求解

### 0424 

数组中的逆序对数

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

示例 1:

输入: [7,5,6,4]
输出: 5

 

### 0425

- 全排列问题比如给1，2，3要写出6种全排列

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

思路是：回溯算法

- 既然都做了回溯算法，就做一下N皇后问题

- 参加的力扣比赛，就做出来一道题：期望个数统计

[题目地址](https://leetcode-cn.com/contest/season/2020-spring/problems/qi-wang-ge-shu-tong-ji/)

其实代码很简单就是去重，但是这道题给它讲的太复杂了，特别是还有期望值的公式，但是简单来说，不管是多少个重复的数，最后取到的期望就是1

比如1的期望是1

1，1的期望还是1，设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 `[[0,1],[1,0]]` 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 `[0,1]` 或者 `[1,0]` ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 `X` 的期望是 (2+0+2+0) * 1/4 = 1

```java
class Solution {
    public int expectNumber(int[] scores) {
             HashSet<Integer> set =new HashSet<>(scores.length );
       for(int one: scores){
           set.add(one);
       }
       return set.size();  
    }
}
```

- 

 ## 自我总结

从0422-0422的这几天我都有些偷懒，主要是心情莫名其妙的被破坏了，接下来的一周到五一结束一定要加倍的努力才行

### 0426

- 合并K个有序链表

第一种方法：挨个遍历K个链表，然后找最小的

第二种方法：优先队列，最小堆。

第三种方法：两两合并链表

- 递归方式，两两合并

```java
private ListNode merge2Lists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = merge2Lists(l1.next, l2);
        return l1;
    }
    l2.next = merge2Lists(l1, l2.next);
    return l2;
}
```

```java
private ListNode merge2Lists(ListNode l1, ListNode l2) {
    //注意这里的dumyHead是必须的，不能单独用一个tail，这样做不了
    ListNode dummyHead = new ListNode(0);
    ListNode tail = dummyHead;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            tail.next = l1;
            l1 = l1.next;
        } else {
            tail.next = l2;
            l2 = l2.next;
        }
        tail = tail.next;
    }

    tail.next = l1 == null? l2: l1;

    return dummyHead.next;
}
 
```

所以合并K个是两两合并

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode res = null;
        for (ListNode list: lists) {
            res = merge2Lists(res, list);
        }
        return res;
    }
}
 
```

### 0427 

  [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

思路是二分法，如果还想继续优化，就是判断哪里旋转了

### 0428

- 一个数组里面有1个不是成对出现的（异或）
- 一个数组里面有2个不是成对出现的（比较麻烦）
  - 先异或求出两个数的异或值
  - 然后求出lowbit
  - 对数组进行下面lowbit之后的运算

```java
 public int[] singleNumbers(int[] nums) {
        int sum = 0;
        int[] res = new int[2];
        for(int num : nums){
            sum ^= num;
        }
        int lowbit = sum & (-sum);
        for(int num : nums){
            if((num & lowbit) == 0){
                res[0] ^= num;
            }else{
                res[1] ^= num;
            }
        }
        return res;
    }
```

### 0429 

- 求山峰数组的最高点log(n)

  - 二分法（参见算法总结里面的关于二分法的详细解释）

### 0430

- 快乐数（力扣202）
  - 思路是如果是快乐数，那么必然没有环路，而找是否有环，我们只需要用快慢指针即可

```java
 int bitSquareSum(int n) {
        int sum = 0;
        while(n > 0)
        {
            int bit = n % 10;
            sum += bit * bit;
            n = n / 10;
        }
        return sum;
    }
    
    boolean isHappy(int n) {
        int slow = n, fast = n;
        do{
            slow = bitSquareSum(slow);
            fast = bitSquareSum(fast);
            fast = bitSquareSum(fast);
        }while(slow != fast);
        
        return slow == 1;
    }
```

### 0501

- 合并两个有序链表

  - 思路是：递归或者用while循环形式的头指针插入法

- 回顾一下：合并链表的扩展版本：合并K个有序链表

  - 最先想到的题解：K个指针指向K个链表，找出最小的插入到新的链表里面

  - 题解一：两两合并
  - 题解二：优先队列
```java
  public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> pq = new PriorityQueue<>((v1, v2) -> v1.val - v2.val);
        for (ListNode node: lists) {
            if (node != null) {
                pq.offer(node);
            }
        }

        ListNode dummyHead = new ListNode(0);
        ListNode tail = dummyHead;
        while (!pq.isEmpty()) {
            ListNode minNode = pq.poll();
            tail.next = minNode;
            tail = minNode;
            if (minNode.next != null) {
                pq.offer(minNode.next);
            }
        }

        return dummyHead.next;
    } 
```

### 0502 

- 无重复子字符串

力扣3题，解题思路是滑动窗口

利用一个Map存放当前已经存放过的数据

当发现一个数据出现重复的时候，更新Left指针

### 0503 

- 最大子序列和的数组
  - 解题思路是：滑动窗口，当和大于0的时候继续向后找，同时更新最大和，如果和小于0，则更新left指针

### 0504 

- 跳跃游戏2——找到跳到终点最小的步数

  - 其实这给是跳跃游戏1的升级版，
  - 跳跃游戏1
    - 我们只需要用动态规划更新每一格能跳的最长距离，当发现最长距离大于等于总路径的时候，即可返回
    - 或者我们找那么当前能跳是0的格子，向前查询，当发现有一个能跳过来的时候即可返回，继续向后查询0的格子，直到最后
  - 跳跃游戏2
    - 类似更新最长距离，在每一格的最长距离更新之后，步数加1

  ```java
  
  ```

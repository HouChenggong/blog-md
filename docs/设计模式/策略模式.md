## 策略模式

### 大部分的涉及模式思想-多态



### 使用的原则-开闭原则

对修改关闭，对扩展开放

策略模式遵循开闭原则，实现代码的解耦合。扩展新的方法时也比较方便，只需要继承策略接口就好了

### 策略模式要解决的问题？

其实就是过多的if或者switch问题

```java
public class Example {

    public String selectPayWay(Integer payCode){
        if(PayWayEnum.WEICHAT_PAY.equals(payCode)){
            //do something
            return "微信支付成功";
        }else if(PayWayEnum.AL_PAY.equals(payCode)){
            // do something
            return "支付宝支付成功";
        }else if(PayWayEnum.CARD_PAY.equals(payCode)){
            // do something
            return "银行卡成功";
        }else if(PayWayEnum.PONIT_COUPON_PAY.equals(payCode)){
            // do something
            return "优惠券支付成功";
        }else {
            return "";
        }
    }

}
```

### 策略模式demo

#### 策略接口

```java
public interface PayStrategy {
    String selectPayWay(Integer paycode);
}
```

#### N种实现

```java
public class ALPayStrategy implements PayStrategy {

    @Override
    public String selectPayWay(Integer paycode) {
        //do something
        return "支付宝支付成功";
    }
}
```

```java
public class CardPayStrategy implements PayStrategy {
    @Override
    public String selectPayWay(Integer paycode) {
        //do something
        return "银行卡支付成功";
    }
}
```

```java
public class WeChatPayStrategy implements PayStrategy {

    @Override
    public String selectPayWay(Integer paycode) {
        //do something
        return "微信支付成功";
    }

}
```

```java
public class PointCouponPayStrategy implements PayStrategy {

    @Override
    public String selectPayWay(Integer paycode) {
        //do something
        return "点券支付成功";
    }
}
```

#### 策略上下文切换

```
public class PayContext {

    private PayStrategy payStrategy;

    public String selectPayWay(Integer payCode){
        payStrategy =  StrategyFactory.getInstance().create(payCode);
        return payStrategy.selectPayWay(payCode);
    }

    public PayStrategy getPayStrategy() {
        return payStrategy;
    }

    public void setPayStrategy(PayStrategy payStrategy) {
        this.payStrategy = payStrategy;
    }
}
```



https://blog.csdn.net/qq1037893644/article/details/102681593

策略工厂模式

https://www.jianshu.com/p/6d6c92819c68

- 传入一个类型，动态的获取实例对象

```java
public class StrategyFactory {
    private static StrategyFactory strategyFactory = new StrategyFactory();
    private static Map<String, Strategy> factory = new HashMap<>();

    private StrategyFactory() {
    }

    static {
        factory.put(MeterType.METER_A.getType(), new MeterA());
        factory.put(MeterType.METER_B.getType(), new MeterB());
    }

    /**
     * 返回对应厂商的实现对象
     *
     * @param type
     * @return
     */
    public static Strategy getInstance(String type) {
        return factory.get(type);
    }
}
```





和工厂模式的比较：
1.工厂模式封装的是对象，策略模式封装的是算法
2.工厂模式可能需要将工厂和产品都暴露给调用方，因为调用方可能会用到产品的不同方面。
但是策略模式，只需要将context暴露给调用方，其内部算法对调用方不可见，不需要将算法子类暴露出去，因为这些算法，本质上都是完成同一件事的不同方法。

















 
# 算法

##  动态规划


- [力扣542-矩阵找出每个元素到最近的 0 的距离](https://leetcode-cn.com/problems/01-matrix/)
  - [解题地址](./docs/算法/力扣542矩阵距离0的最短举例.md)

  - BFS解法

  - 此题也能用递归做

动态规划解题三要素

- 简单的说就是定义dp[i]表示的问题或者转态是什么。一般来说，这个问题定义清楚，就成功了大半。
- 状态转移方程：转态转移就是根据子问题（上一阶段）状态和决策来导出本问题（当前阶段）的状态，确定了决策方法，就可以写出转态转移方程。
- 边界条件：状态转移方程是一个递推式，需要一个递推的边界条件来最终解出动态规划问题。

 



##   双指针

###  力扣11，盛水最多的容器

- [解题地址](./docs/算法/lt11盛水最多的容器.md)


##  递归
### 力扣200 找出岛屿数量

- [解题地址](./docs/算法/力扣200找出岛屿数量.md)

### 二叉树首个共同祖先

- [解题地址](./docs/算法/二叉树首个共同祖先.md)


## 普通BFS

```java
while queue 不空：
    cur = queue.pop()
    for 节点 in cur的所有相邻节点：
        if 该节点有效且未访问过：
            queue.push(该节点)
```

###  力扣542-矩阵找出每个元素到最近的 0 的距离

  - [解题地址](./docs/算法/力扣542矩阵距离0的最短举例.md)

  - BFS解法

  - 此题也能用递归做
### 力扣200 找出岛屿数量

[解题地址](./docs/算法/力扣200找出岛屿数量.md)






##  带有层级的BFS



```java
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for 节点 in cur的所有相邻节点：
            if 该节点有效且未被访问过：
                queue.push(该节点)
    }
    level ++;
```


# 算法

## 位运算

```java
我们先来看下异或的性质（数学里异或的符号是 ⊕）：

交换律：p ⊕ q = q ⊕ p
结合律：p ⊕ (q ⊕ r) = (p ⊕ q) ⊕ r
恒等率：p ⊕ 0 =p
归零率：p ⊕ p =0
```

- N个数字进行异或运算，如果只有一个不同的，那么异或的结果就是那个数字
- N个数字进行异或运算，如果有2个不同的，那么异或的结果是两个不同的数字异或的结果result，即p⊕ q,如果要求出p和q怎么办
  - 分成2组，一组是P，一组是Q，所以现在问题转换到了如何分组上面
  - 对异或的结果进行分析，这个数字从二进制数的角度看，一定有位数为1。这个1是怎么来的？就是那两个只出现一次的数字，异或得到的，他们对应的位不一样，肯定是一个数对应位数出现的是0，另一个数字对应位置上出现的数字是1.据此，将这个数组分成两个部分。
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### lowbit

```java
lowbit（）函数用来取一个二进制最低位的1与后边的0组成的数

例：5（101），lowbit（5）=1（1）

       12（1100），lowbit（12）=4（100）

int lowbit(int t)
{
    return t&(-t);
}
原理，二进制数的负数是正数取反加一

12（1100），-12（0100）
```



##  动态规划


- [力扣542-矩阵找出每个元素到最近的 0 的距离](https://leetcode-cn.com/problems/01-matrix/)
  - [解题地址](./docs/算法/力扣542矩阵距离0的最短举例.md)

  - BFS解法

  - 此题也能用递归做

动态规划解题三要素

- 简单的说就是定义dp[i]表示的问题或者转态是什么。一般来说，这个问题定义清楚，就成功了大半。
- 状态转移方程：转态转移就是根据子问题（上一阶段）状态和决策来导出本问题（当前阶段）的状态，确定了决策方法，就可以写出转态转移方程。
- 边界条件：状态转移方程是一个递推式，需要一个递推的边界条件来最终解出动态规划问题。

 

## 滑动窗口

### 力扣1248滑动窗口求组合数量

- 解题思路，利用滑动窗口和公式（left偶数和+1）*（right偶数和+1）
- [解题地址](./docs/算法/1248.md)

### 无重复最长子字符串

- 力扣3题，解题思路是滑动窗口
  - 利用一个Map存放当前已经存放过的数据
  - 当发现一个数据出现重复的时候，更新Left指针

```java
   public int lengthOfLongestSubstring(String s) {
        if (s.length()==0) return 0;
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        int max = 0;
        int left = 0;
        for(int i = 0; i < s.length(); i ++){
            if(map.containsKey(s.charAt(i))){
                left = Math.max(left,map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i),i);
            max = Math.max(max,i-left+1);
        }
        return max;
        
    }
```




##   双指针



###  力扣11，盛水最多的容器

- [解题地址](./docs/算法/lt11盛水最多的容器.md)

### 力扣202 快乐数

- 解题思路，用快慢指针找有没有环即可


##  递归
### 力扣200 找出岛屿数量

- [解题地址](./docs/算法/力扣200找出岛屿数量.md)

### 二叉树首个共同祖先

- [解题地址](./docs/算法/二叉树首个共同祖先.md)


## 普通BFS

```java
while queue 不空：
    cur = queue.pop()
    for 节点 in cur的所有相邻节点：
        if 该节点有效且未访问过：
            queue.push(该节点)
```

###  力扣542-矩阵找出每个元素到最近的 0 的距离

  - [解题地址](./docs/算法/力扣542矩阵距离0的最短举例.md)

  - BFS解法

  - 此题也能用递归做
### 力扣200 找出岛屿数量

[解题地址](./docs/算法/力扣200找出岛屿数量.md)






##  带有层级的BFS



```java
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for 节点 in cur的所有相邻节点：
            if 该节点有效且未被访问过：
                queue.push(该节点)
    }
    level ++;
```
## 递归回溯算法

```java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```

核心是：

```java
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
 
```



#### 全排列问题



  -  比如说是1，2，3，4，5

  -  核心是撤销和选择，也就是前序遍历问题，当遍历到最后一层i=4,也就是1，2，3，4，5，把最后一个5撤销，然后回到i=3,然后把4也撤销，把5填上，然后挨个撤销和补上

```
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
    public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        List<List<Integer>> res = new ArrayList<>(factorial(len));
        if (len == 0) {
            return res;
        }
        Deque<Integer> path = new ArrayDeque<>(len);
        dfs(nums, len, 0, path, res);
        return res;
    }
	//计算全排列总数据量
    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i <= n; i++) {
            res *= i;
        }
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     Deque<Integer> path, 
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < len; i++) {
        //排除不合法的请求
            if (!path.contains(nums[i])) {
                //一条路径里添加当前值
                path.addLast(nums[i]);
                //进入下一层决策树
				//递归调用剩下的组合，这个和二叉树差不多都是前序遍历，会先遍历完一条路径
                dfs(nums, len, depth + 1, path, res);
				//移掉最后一个
                path.removeLast();
               
            }
        }
    }
}
 
```



#### N皇后问题

其实也是套用模板只不过不再是`if (!path.contains(nums[i]))`

而是： `if (!isValid(board, row, col)) continue;`

只要你实现这个isValid算法即可

## 贪心算法

#### 求出去AB城市的最少费用

```java
公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。
返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。
示例：
输入：[[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。
最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
```

- 题解：只需要重写sort接口，然后取前1半的数据即可

#### 跳跃游戏

```java
55. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例 2:
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

- 题解一：贪心算法，就挨着跳，每一步计算当前能跳的最远值，如果最远值大于目标值，true，如果结束了，最远值还是小于目标值，则false
- 题解二：其实只要数组的值大于0，都能跳，所以我们就找0，找到一个0，向前面遍历，看看它前面的数字是否能跳过它即可

#### 最后一块石头的重量

```java
有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
示例
输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
```

- 题解1 ，优先队列先排序，然后每次取出2个，比较完，扔进去，最后返回即可

## 二分法

### 二分模板，只需要记住这一个即可

记住循环条件是l<r，而且返回结果不管是L还是R都是可以的

```java
  public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        if (target > nums[len - 1]) {
            return len;
        }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return right;
    }
```

###  求山峰数组最高点索引值

[题目地址](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)



在一个山峰数组中，只有3种情况

- 第一种：当前值的大于左边的
- 第二种：当前值的小于左边的
- 第三种：当前值大于左边的，而且大于右边的

```java
    public int peakIndexInMountainArray(int[] arr) {
             int len = arr.length;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1]) {
                return mid;
            }else if(arr[mid]>arr[mid-1]){
                left=mid+1;
            }else if(arr[mid]<arr[mid-1]){
                right=mid;
            }else {
               // System.out.println("这个根本不会进入");
            }
        }
        //这里随便return，因为肯定会返回
        return -1;
    }
```

## 优先队列

### 合并K个有序链表

```java
  public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> pq = new PriorityQueue<>((v1, v2) -> v1.val - v2.val);
        for (ListNode node: lists) {
            if (node != null) {
                pq.offer(node);
            }
        }

        ListNode dummyHead = new ListNode(0);
        ListNode tail = dummyHead;
        while (!pq.isEmpty()) {
            ListNode minNode = pq.poll();
            tail.next = minNode;
            tail = minNode;
            if (minNode.next != null) {
                pq.offer(minNode.next);
            }
        }

        return dummyHead.next;
    } 
```


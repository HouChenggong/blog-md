

### try catch 相关

当catch和finally都有返回的时候，执行finally返回

https://blog.csdn.net/qq_39455116/article/details/87880574

### final关键字

关键字主要用在三个地方：变量、方法、类。

1. 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。
3. 当final修饰方法时，方法不能被重写

### MCVV和事务



### RDB和AOF以及AOF重写



### 手写双向链表



### JDK8多线程并行



### IOC相关



### @Resouce和@Aut

@Autowire默认按照类型装配，默认情况下它要求依赖对象必须存在如果允许为null，可以设置它required属性为false，如果我们想使用按照名称装配，可以结合@Qualifier注解一起使用;


@Resource默认按照名称装配，当找不到与名称匹配的bean才会按照类型装配，可以通过name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象.

注意：如果没有指定name属性，并且按照默认的名称仍然找不到依赖的对象时候，会回退到按照类型装配，但一旦指定了name属性，就只能按照名称装配了.

### 索引

### 单例模式

### 消息的重复消费

### 过滤器、拦截器、监听器

- 过滤器
  - 通过过滤器过滤资源
  - 基于函数调用
  - 比如说SQL、XSS注入

```
public interface Filter {
	//容器初始化时调用一次
    void init(FilterConfig var1) throws ServletException;
	
    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;
	//容器销毁时调用一次
    void destroy();
}
```

- 拦截器
  - 基于反射机制

```
public interface HandlerInterceptor {
	// 在业务处理器处理请求之前被调用
    boolean preHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;
	//在业务处理器处理请求之后被调用
    void postHandle(HttpServletRequest var1, HttpServletResponse var2, Object var3, ModelAndView var4) throws Exception;
	//在DispatcherServlet完全处理完请求后被调用 
    void afterCompletion(HttpServletRequest var1, HttpServletResponse var2, Object var3, Exception var4) throws Exception;
}
```

- 监听器

```

```



### redis为啥快？

- 纯内存
- 单线程，避免频繁的上下文切换
- 非阻塞IO多路复用机制

### redis为啥可以用作分布式锁？

- 单线程

### 缓存击穿、穿透、雪崩

- 击穿：刚好过期

  - 发现不存在，添加分布式锁，加完锁之后，查询缓存，如果还不存在，查询数据库，然后写缓存，后面的用户再次查询缓存就会有缓存

    

- 缓存穿透：不存在的数据，恶意用户
  - 数据校验
  - 不聋过滤器

### 双写一致性

#### 先更新数据库，再更新缓存

- 会存在更新缓存失败的情况

#### 先删除缓存再更新数据库

线程A，更新，删除缓存

线程B，查询，发现缓存没有数据，就把旧的数据更新到缓存中

-  解决方案：
  - 先删除缓存，更新数据库
  - 然后程序睡眠3s，然后再次删除缓存，保证在休眠的这三秒，其它操作导致的插入缓存被删除
- 再次优化
  - 先删除缓存，更新数据库，然后休眠3s，然后异步删除
  - 但是会导致异步删除失败的情况

### 先更新数据库，再删除缓存

- 如果缓存删除失败了，则都是旧的值

#### 最终方案：队列

- 读写串行化到一个队列中，但是要化好几倍的机器来处理
- 但是队列也有数据锁历史数据的问题，所以还是采用先删除缓存，更新数据库锁，然后再次删除缓存的机制
- 或者删除（更新）缓存的时候添加分布式锁，让其它线程阻塞，但不上一个很好的解决方案

### hashMap 链表转换红黑树为啥是8？

- 为啥要转换？
  - 因为链表长度太长，遍历的复杂度是O（n ）
  - 而红黑树的插入、删除和遍历复杂度都是long(n)
- 为啥是8？
  - 因为根据hashMap的文档，简单解释一下，理想情况下，在随机哈希代码下，桶中的节点频率遵循
    泊松分布，文中给出了桶长度k的频率表。
    由频率表可以看出，桶的长度超过8的概率非常非常小

### 快排

### JVM调优

- CPU100% 
- 内存溢出、泄漏

### 设计模式

### 动态代理的实现

### park unpack  yield  Thread哪些静态方法

- yield

暂停当前执行的线程对象，并执行其他线程。这个暂停是会放弃CPU资源的，并且放弃CPU的时间不确定。
 让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。

```java
  //当前线程
  public static native Thread currentThread();
  //
      public static native void yield();
      
  public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
    
    
    public static int activeCount() {
        return currentThread().getThreadGroup().activeCount();
    }
    
     public static native boolean holdsLock(Object obj);
```

- yield和sleep的区别？
  - 都不会放弃锁
  - 都会暂停当前线程
  - 不同点：sleep可以指定休眠时间，而yield依赖CPU的时间片花粉
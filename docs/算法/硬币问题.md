## 硬币问题，有多少种方案？

```java

```

## 数学解法

这道题根本不会存在某一种解法不存在的情况，因为最新的硬币是1

 比如说我们确定了25的个数，再确定10的个数，再确定5的个数，然后1的个数就是确定的值，所以我们写下来了下面的解法



```java
   public  int waysToChange(int n) {
       int res = 0;
       for(int n25 = 0; n25 <= n/25; n25++)  //一个一个试每一种可能的n25数。
       {
           int temp1 = n - n25*25;
           for(int n10 = 0; n10 <= temp1/10; n10++)
           {
               res += (temp1 - n10*10)/5+1;
           }
       }
       return res;

    }
```

- 这个在当前的4种硬币的情况下，复杂度不是很高，但是能不能把里面的for循环去掉呢？

### 数学的优化解法：等差数列和

到这里，测试一下题目要求的最大值，哦霍，还是超时
乍一看，好想没什么优化的方式了，但其实还有个数学方法，你可以发现现在的内循环n10其实每次的变化都是有规律的，每次res+的数也是有规律的，你只要稍微想想就知道，每两个循环res+的数的差是相等的，也就是我们常说的等差数列，于是乎，我们可以想到高中学的等差数列求和。
这里就讲下结论，等差数列的和 == (首项 + 末项) * 项数 / 2
于是，用这个方法进一步优化代码

 首项是`temp/5+1`，就是当10元的硬币数量是0的情况下，即下面的

末项是`(temp%10)/5+1`就是当10元的硬币达到当前最大的情况下

项数是`(temp/10+1)`就是有多少种10元硬币的情况

```
        public int waysToChange(int n) {
                      int total = 0;
            //一个一个试每一种可能的n25数。
            for (int i = 0; i <= n / 25; i++) {
                //用了i个25之后的结果
                int temp = n - i * 25;
                //项数
                int tempNum = temp / 10 + 1;
                //首项即0个10的情况
                int headNum = temp / 5 + 1;
                //能用10都用10的情况
                int tailNum = temp % 10/5 + 1;
                total += tempNum * (tailNum + headNum) / 2;
            }
            return total;
        }
```

注意等差数列的和可能会大于int的范围，于是在计算时就强制转换了下类型，取余之后是肯定在int范围里的 ，所以上面两个方法在数值非常大的时候会报错，比如

```
当数值是：900750
上面两种情况执行的结果都是：1991891502
但是实际的结果是：504188296
```

- 所以我们要进行long类型转换和取模

### long类型转换和取模

把上面的代码进行如下修改:

```java
public static int waysToChange2(int n) {
    long total = 0;
    //一个一个试每一种可能的n25数。
    for (int i = 0; i <= n / 25; i++) {
        //用了i个25之后的结果
        int temp = n - i * 25;
        //项数
        int tempNum = temp / 10 + 1;
        //首项即0个10的情况
        int headNum = temp / 5 + 1;
        //能用10都用10的情况
        int tailNum = (temp % 10) / 5 + 1;
        //long类型转换并去取模
        long oneMax = ((long) tempNum * (tailNum + headNum) / 2) % 1000000007;
        //再次取模
        total = (oneMax + total) % 1000000007;


    }
    return (int)total;
}
```

## 动态规划

